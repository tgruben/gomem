// Code generated by pkg/object/object.gen.go.tmpl. DO NOT EDIT.

// Copyright 2019 Nick Poorman
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package object

import (
	"fmt"
	"math"

	"github.com/apache/arrow/go/v10/arrow"
	"github.com/apache/arrow/go/v10/arrow/decimal128"
	"github.com/apache/arrow/go/v10/arrow/float16"
)

var (
	MaxBoolean         = Boolean(true)
	MaxDate32          = Date32(math.MaxInt32)
	MaxDate64          = Date64(math.MaxInt64)
	MaxDayTimeInterval = DayTimeInterval(arrow.DayTimeInterval{Days: math.MaxInt32, Milliseconds: math.MaxInt32})
	MaxDecimal128      = Decimal128(decimal128.MaxDecimal128)
	MaxDuration        = Duration(math.MaxInt64)
	MaxFloat16         = Float16(float16.New(65504))
	MaxFloat32         = Float32(math.MaxFloat32)
	MaxFloat64         = Float64(math.MaxFloat64)
	MaxInt16           = Int16(math.MaxInt16)
	MaxInt32           = Int32(math.MaxInt32)
	MaxInt64           = Int64(math.MaxInt64)
	MaxInt8            = Int8(math.MaxInt8)
	MaxMonthInterval   = MonthInterval(math.MaxInt32)
	MaxTime32          = Time32(math.MaxInt32)
	MaxTime64          = Time64(math.MaxInt64)
	MaxTimestamp       = Timestamp(math.MaxInt64)
	MaxUint16          = Uint16(math.MaxUint16)
	MaxUint32          = Uint32(math.MaxUint32)
	MaxUint64          = Uint64(math.MaxUint64)
	MaxUint8           = Uint8(math.MaxUint8)
)

type CastableToBoolean interface {
	ToBooleanChecked() (Boolean, Boolean)
	ToBoolean() Boolean
}

// CastToBoolean takes an interface{} type or any Object type and
// attempts to convert it to the Boolean Object type.
func CastToBoolean(v interface{}) (Boolean, bool) {
	switch pt := v.(type) {
	case *Boolean:
		return *pt, true
	case Boolean:
		return pt, true
	case *bool:
		t := *pt
		return Boolean(t), true
	case bool:
		t := pt
		return Boolean(t), true
	case *Date32:
		t := *pt
		return Boolean(t != 0), true
	case Date32:
		t := pt
		return Boolean(t != 0), true
	case *Date64:
		t := *pt
		return Boolean(t != 0), true
	case Date64:
		t := pt
		return Boolean(t != 0), true
	case *DayTimeInterval:
		t := *pt
		return Boolean(t.Days != 0 || t.Milliseconds != 0), true
	case DayTimeInterval:
		t := pt
		return Boolean(t.Days != 0 || t.Milliseconds != 0), true
	case *Decimal128:
		t := *pt
		return Boolean(t.Sign() != 0), true
	case Decimal128:
		t := pt
		return Boolean(t.Sign() != 0), true
	case *Duration:
		t := *pt
		return Boolean(t != 0), true
	case Duration:
		t := pt
		return Boolean(t != 0), true
	case *Float16:
		t := *pt
		return Boolean(t.Uint16() != 0), true
	case Float16:
		t := pt
		return Boolean(t.Uint16() != 0), true
	case *Float32:
		t := *pt
		return Boolean(t != 0.0), true
	case Float32:
		t := pt
		return Boolean(t != 0.0), true
	case *Float64:
		t := *pt
		return Boolean(t != 0.0), true
	case Float64:
		t := pt
		return Boolean(t != 0.0), true
	case *Int16:
		t := *pt
		return Boolean(t != 0), true
	case Int16:
		t := pt
		return Boolean(t != 0), true
	case *Int32:
		t := *pt
		return Boolean(t != 0), true
	case Int32:
		t := pt
		return Boolean(t != 0), true
	case *Int64:
		t := *pt
		return Boolean(t != 0), true
	case Int64:
		t := pt
		return Boolean(t != 0), true
	case *Int8:
		t := *pt
		return Boolean(t != 0), true
	case Int8:
		t := pt
		return Boolean(t != 0), true
	case *MonthInterval:
		t := *pt
		return Boolean(t != 0), true
	case MonthInterval:
		t := pt
		return Boolean(t != 0), true
	case *Null:
		t := *pt
		return t.ToBoolean(), true
	case Null:
		t := pt
		return t.ToBoolean(), true
	case *String:
		t := *pt
		return Boolean(t != ""), true
	case String:
		t := pt
		return Boolean(t != ""), true
	case *Time32:
		t := *pt
		return Boolean(t != 0), true
	case Time32:
		t := pt
		return Boolean(t != 0), true
	case *Time64:
		t := *pt
		return Boolean(t != 0), true
	case Time64:
		t := pt
		return Boolean(t != 0), true
	case *Timestamp:
		t := *pt
		return Boolean(t != 0), true
	case Timestamp:
		t := pt
		return Boolean(t != 0), true
	case *Uint16:
		t := *pt
		return Boolean(t != 0), true
	case Uint16:
		t := pt
		return Boolean(t != 0), true
	case *Uint32:
		t := *pt
		return Boolean(t != 0), true
	case Uint32:
		t := pt
		return Boolean(t != 0), true
	case *Uint64:
		t := *pt
		return Boolean(t != 0), true
	case Uint64:
		t := pt
		return Boolean(t != 0), true
	case *Uint8:
		t := *pt
		return Boolean(t != 0), true
	case Uint8:
		t := pt
		return Boolean(t != 0), true
	default:
		// Also handles when v is nil
		return false, false
	}
}

// NewBoolean creates a new Boolean object
// from the given value provided as v.
func NewBoolean(v bool) Boolean {
	return Boolean(v)
}

// Boolean has logic to apply to this type.
type Boolean bool

// Value returns the underlying value in it's native type.
func (e Boolean) Value() bool {
	return bool(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Boolean) compareTypes(r Object, f func(bool, bool) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Boolean:
		return f(e.Value(), right.Value()), nil
	case *Boolean:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Boolean", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Boolean is equal to the right Boolean.
func (e Boolean) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right bool) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Boolean
// is not equal to the right Boolean.
func (e Boolean) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// ToBooleanChecked attempts to cast the Boolean to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Boolean to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Boolean) ToBoolean() Boolean {
	return t
}

// ToDate32Checked attempts to cast the Boolean to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Boolean to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToDate32() Date32 {
	if t {
		return Date32(1)
	}
	return Date32(0)
}

// ToDate64Checked attempts to cast the Boolean to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Boolean to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToDate64() Date64 {
	if t {
		return Date64(1)
	}
	return Date64(0)
}

// ToDayTimeIntervalChecked attempts to cast the Boolean to a DayTimeInterval.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToDayTimeIntervalChecked() (DayTimeInterval, Boolean) {
	return t.ToDayTimeInterval(), true
}

// ToDayTimeInterval attempts to cast the Boolean to a DayTimeInterval.
// The result is not checked for an overflow.
// Use the ToDayTimeIntervalChecked version of this method if you need to check for
// an overflow.
func (t Boolean) ToDayTimeInterval() DayTimeInterval {
	if t {
		return DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 1})
	}
	return DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})
}

// ToDecimal128Checked attempts to cast the Boolean to a Decimal128.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToDecimal128Checked() (Decimal128, Boolean) {
	return t.ToDecimal128(), true
}

// ToDecimal128 attempts to cast the Boolean to a Decimal128.
// The result is not checked for an overflow.
// Use the ToDecimal128Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToDecimal128() Decimal128 {
	if t {
		return NewDecimal128FromU64(1)
	}
	return NewDecimal128FromU64(0)
}

// ToDurationChecked attempts to cast the Boolean to a Duration.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToDurationChecked() (Duration, Boolean) {
	return t.ToDuration(), true
}

// ToDuration attempts to cast the Boolean to a Duration.
// The result is not checked for an overflow.
// Use the ToDurationChecked version of this method if you need to check for
// an overflow.
func (t Boolean) ToDuration() Duration {
	if t {
		return Duration(1)
	}
	return Duration(0)
}

// ToFloat16Checked attempts to cast the Boolean to a Float16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToFloat16Checked() (Float16, Boolean) {
	return t.ToFloat16(), true
}

// ToFloat16 attempts to cast the Boolean to a Float16.
// The result is not checked for an overflow.
// Use the ToFloat16Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToFloat16() Float16 {
	if t {
		return Float16(float16.New(1))
	}
	return Float16(float16.New(0))
}

// ToFloat32Checked attempts to cast the Boolean to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Boolean to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToFloat32() Float32 {
	if t {
		return Float32(1)
	}
	return Float32(0)
}

// ToFloat64Checked attempts to cast the Boolean to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Boolean to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToFloat64() Float64 {
	if t {
		return Float64(1)
	}
	return Float64(0)
}

// ToInt16Checked attempts to cast the Boolean to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Boolean to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToInt16() Int16 {
	if t {
		return Int16(1)
	}
	return Int16(0)
}

// ToInt32Checked attempts to cast the Boolean to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Boolean to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToInt32() Int32 {
	if t {
		return Int32(1)
	}
	return Int32(0)
}

// ToInt64Checked attempts to cast the Boolean to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Boolean to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToInt64() Int64 {
	if t {
		return Int64(1)
	}
	return Int64(0)
}

// ToInt8Checked attempts to cast the Boolean to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Boolean to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToInt8() Int8 {
	if t {
		return Int8(1)
	}
	return Int8(0)
}

// ToMonthIntervalChecked attempts to cast the Boolean to a MonthInterval.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToMonthIntervalChecked() (MonthInterval, Boolean) {
	return t.ToMonthInterval(), true
}

// ToMonthInterval attempts to cast the Boolean to a MonthInterval.
// The result is not checked for an overflow.
// Use the ToMonthIntervalChecked version of this method if you need to check for
// an overflow.
func (t Boolean) ToMonthInterval() MonthInterval {
	if t {
		return MonthInterval(1)
	}
	return MonthInterval(0)
}

// ToStringChecked attempts to cast the Boolean to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Boolean to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Boolean) ToString() String {
	return String(fmt.Sprintf("%t", t))
}

// ToTime32Checked attempts to cast the Boolean to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Boolean to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToTime32() Time32 {
	if t {
		return Time32(1)
	}
	return Time32(0)
}

// ToTime64Checked attempts to cast the Boolean to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Boolean to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToTime64() Time64 {
	if t {
		return Time64(1)
	}
	return Time64(0)
}

// ToTimestampChecked attempts to cast the Boolean to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Boolean to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Boolean) ToTimestamp() Timestamp {
	if t {
		return Timestamp(1)
	}
	return Timestamp(0)
}

// ToUint16Checked attempts to cast the Boolean to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Boolean to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToUint16() Uint16 {
	if t {
		return Uint16(1)
	}
	return Uint16(0)
}

// ToUint32Checked attempts to cast the Boolean to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Boolean to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToUint32() Uint32 {
	if t {
		return Uint32(1)
	}
	return Uint32(0)
}

// ToUint64Checked attempts to cast the Boolean to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Boolean to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToUint64() Uint64 {
	if t {
		return Uint64(1)
	}
	return Uint64(0)
}

// ToUint8Checked attempts to cast the Boolean to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Boolean) ToUint8Checked() (Uint8, Boolean) {
	return t.ToUint8(), true
}

// ToUint8 attempts to cast the Boolean to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Boolean) ToUint8() Uint8 {
	if t {
		return Uint8(1)
	}
	return Uint8(0)
}

type CastableToDate32 interface {
	ToDate32Checked() (Date32, Boolean)
	ToDate32() Date32
}

// CastToDate32 takes an interface{} type or any Object type and
// attempts to convert it to the Date32 Object type.
func CastToDate32(v interface{}) (Date32, bool) {
	switch pt := v.(type) {
	case *Date32:
		return *pt, true
	case Date32:
		return pt, true
	case *arrow.Date32:
		t := *pt
		return Date32(t), true
	case arrow.Date32:
		t := pt
		return Date32(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Date32 {
			if t {
				return Date32(1)
			}
			return Date32(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Date32 {
			if t {
				return Date32(1)
			}
			return Date32(0)
		}(t), true
	case *Date64:
		t := *pt
		return Date32(t), true
	case Date64:
		t := pt
		return Date32(t), true
	case *Decimal128:
		t := *pt
		return Date32(t.toI64()), true
	case Decimal128:
		t := pt
		return Date32(t.toI64()), true
	case *Duration:
		t := *pt
		return Date32(t), true
	case Duration:
		t := pt
		return Date32(t), true
	case *Float16:
		t := *pt
		return Date32(t.tof32()), true
	case Float16:
		t := pt
		return Date32(t.tof32()), true
	case *Float32:
		t := *pt
		return Date32(t), true
	case Float32:
		t := pt
		return Date32(t), true
	case *Float64:
		t := *pt
		return Date32(t), true
	case Float64:
		t := pt
		return Date32(t), true
	case *Int16:
		t := *pt
		return Date32(t), true
	case Int16:
		t := pt
		return Date32(t), true
	case *Int32:
		t := *pt
		return Date32(t), true
	case Int32:
		t := pt
		return Date32(t), true
	case *Int64:
		t := *pt
		return Date32(t), true
	case Int64:
		t := pt
		return Date32(t), true
	case *Int8:
		t := *pt
		return Date32(t), true
	case Int8:
		t := pt
		return Date32(t), true
	case *Time32:
		t := *pt
		return Date32(t), true
	case Time32:
		t := pt
		return Date32(t), true
	case *Time64:
		t := *pt
		return Date32(t), true
	case Time64:
		t := pt
		return Date32(t), true
	case *Timestamp:
		t := *pt
		return Date32(t), true
	case Timestamp:
		t := pt
		return Date32(t), true
	case *Uint16:
		t := *pt
		return Date32(t), true
	case Uint16:
		t := pt
		return Date32(t), true
	case *Uint32:
		t := *pt
		return Date32(t), true
	case Uint32:
		t := pt
		return Date32(t), true
	case *Uint64:
		t := *pt
		return Date32(t), true
	case Uint64:
		t := pt
		return Date32(t), true
	case *Uint8:
		t := *pt
		return Date32(t), true
	case Uint8:
		t := pt
		return Date32(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewDate32 creates a new Date32 object
// from the given value provided as v.
func NewDate32(v arrow.Date32) Date32 {
	return Date32(v)
}

// Date32 has logic to apply to this type.
type Date32 arrow.Date32

// Value returns the underlying value in it's native type.
func (e Date32) Value() arrow.Date32 {
	return arrow.Date32(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Date32) compareTypes(r Object, f func(arrow.Date32, arrow.Date32) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Date32:
		return f(e.Value(), right.Value()), nil
	case *Date32:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Date32", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Date32 is equal to the right Date32.
func (e Date32) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date32) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Date32
// is not equal to the right Date32.
func (e Date32) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Date32
// is less than the right Date32.
func (e Date32) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date32) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Date32
// is less than or equal to the right Date32.
func (e Date32) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date32) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Date32
// is greter than the right Date32.
func (e Date32) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date32) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Date32
// is greter than or equal to the right Date32.
func (e Date32) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date32) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Date32 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date32) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Date32 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Date32) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Date32 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date32) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Date32 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Date32) ToDate32() Date32 {
	return t
}

// ToDate64Checked attempts to cast the Date32 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date32) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Date32 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Date32) ToDate64() Date64 {
	return Date64(t)
}

// ToInt32Checked attempts to cast the Date32 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date32) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Date32 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Date32) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Date32 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date32) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Date32 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Date32) ToInt64() Int64 {
	return Int64(t)
}

// ToStringChecked attempts to cast the Date32 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date32) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Date32 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Date32) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToUint64Checked attempts to cast the Date32 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date32) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Date32 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Date32) ToUint64() Uint64 {
	return Uint64(t)
}

type CastableToDate64 interface {
	ToDate64Checked() (Date64, Boolean)
	ToDate64() Date64
}

// CastToDate64 takes an interface{} type or any Object type and
// attempts to convert it to the Date64 Object type.
func CastToDate64(v interface{}) (Date64, bool) {
	switch pt := v.(type) {
	case *Date64:
		return *pt, true
	case Date64:
		return pt, true
	case *arrow.Date64:
		t := *pt
		return Date64(t), true
	case arrow.Date64:
		t := pt
		return Date64(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Date64 {
			if t {
				return Date64(1)
			}
			return Date64(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Date64 {
			if t {
				return Date64(1)
			}
			return Date64(0)
		}(t), true
	case *Date32:
		t := *pt
		return Date64(t), true
	case Date32:
		t := pt
		return Date64(t), true
	case *Decimal128:
		t := *pt
		return Date64(t.toI64()), true
	case Decimal128:
		t := pt
		return Date64(t.toI64()), true
	case *Duration:
		t := *pt
		return Date64(t), true
	case Duration:
		t := pt
		return Date64(t), true
	case *Float16:
		t := *pt
		return Date64(t.tof32()), true
	case Float16:
		t := pt
		return Date64(t.tof32()), true
	case *Float32:
		t := *pt
		return Date64(t), true
	case Float32:
		t := pt
		return Date64(t), true
	case *Float64:
		t := *pt
		return Date64(t), true
	case Float64:
		t := pt
		return Date64(t), true
	case *Int16:
		t := *pt
		return Date64(t), true
	case Int16:
		t := pt
		return Date64(t), true
	case *Int32:
		t := *pt
		return Date64(t), true
	case Int32:
		t := pt
		return Date64(t), true
	case *Int64:
		t := *pt
		return Date64(t), true
	case Int64:
		t := pt
		return Date64(t), true
	case *Int8:
		t := *pt
		return Date64(t), true
	case Int8:
		t := pt
		return Date64(t), true
	case *Time32:
		t := *pt
		return Date64(t), true
	case Time32:
		t := pt
		return Date64(t), true
	case *Time64:
		t := *pt
		return Date64(t), true
	case Time64:
		t := pt
		return Date64(t), true
	case *Timestamp:
		t := *pt
		return Date64(t), true
	case Timestamp:
		t := pt
		return Date64(t), true
	case *Uint16:
		t := *pt
		return Date64(t), true
	case Uint16:
		t := pt
		return Date64(t), true
	case *Uint32:
		t := *pt
		return Date64(t), true
	case Uint32:
		t := pt
		return Date64(t), true
	case *Uint64:
		t := *pt
		return Date64(t), true
	case Uint64:
		t := pt
		return Date64(t), true
	case *Uint8:
		t := *pt
		return Date64(t), true
	case Uint8:
		t := pt
		return Date64(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewDate64 creates a new Date64 object
// from the given value provided as v.
func NewDate64(v arrow.Date64) Date64 {
	return Date64(v)
}

// Date64 has logic to apply to this type.
type Date64 arrow.Date64

// Value returns the underlying value in it's native type.
func (e Date64) Value() arrow.Date64 {
	return arrow.Date64(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Date64) compareTypes(r Object, f func(arrow.Date64, arrow.Date64) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Date64:
		return f(e.Value(), right.Value()), nil
	case *Date64:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Date64", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Date64 is equal to the right Date64.
func (e Date64) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date64) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Date64
// is not equal to the right Date64.
func (e Date64) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Date64
// is less than the right Date64.
func (e Date64) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date64) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Date64
// is less than or equal to the right Date64.
func (e Date64) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date64) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Date64
// is greter than the right Date64.
func (e Date64) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date64) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Date64
// is greter than or equal to the right Date64.
func (e Date64) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Date64) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Date64 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Date64 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Date64) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Date64 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToDate32Checked() (Date32, Boolean) {
	var converted Date32
	converted = Date32(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToDate32 attempts to cast the Date64 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Date64 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Date64 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToDate64() Date64 {
	return t
}

// ToFloat32Checked attempts to cast the Date64 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToFloat32Checked() (Float32, Boolean) {
	var converted Float32
	converted = Float32(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToFloat32 attempts to cast the Date64 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Date64 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToFloat64Checked() (Float64, Boolean) {
	var converted Float64
	converted = Float64(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToFloat64 attempts to cast the Date64 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Date64 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Date64 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Date64 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToInt32Checked() (Int32, Boolean) {
	var converted Int32
	converted = Int32(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt32 attempts to cast the Date64 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Date64 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Date64 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Date64 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Date64 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Date64 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Date64 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Date64) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Date64 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToTime32Checked() (Time32, Boolean) {
	var converted Time32
	converted = Time32(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime32 attempts to cast the Date64 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Date64 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Date64 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Date64 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Date64 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Date64) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Date64 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Date64 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Date64 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToUint32Checked() (Uint32, Boolean) {
	var converted Uint32
	converted = Uint32(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint32 attempts to cast the Date64 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Date64 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Date64 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Date64 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Date64) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToDate64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Date64 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Date64) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToDayTimeInterval interface {
	ToDayTimeIntervalChecked() (DayTimeInterval, Boolean)
	ToDayTimeInterval() DayTimeInterval
}

// CastToDayTimeInterval takes an interface{} type or any Object type and
// attempts to convert it to the DayTimeInterval Object type.
func CastToDayTimeInterval(v interface{}) (DayTimeInterval, bool) {
	switch pt := v.(type) {
	case *DayTimeInterval:
		return *pt, true
	case DayTimeInterval:
		return pt, true
	case *arrow.DayTimeInterval:
		t := *pt
		return DayTimeInterval(t), true
	case arrow.DayTimeInterval:
		t := pt
		return DayTimeInterval(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) DayTimeInterval {
			if t {
				return DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 1})
			}
			return DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) DayTimeInterval {
			if t {
				return DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 1})
			}
			return DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})
		}(t), true
	default:
		// Also handles when v is nil
		return DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}), false
	}
}

// NewDayTimeInterval creates a new DayTimeInterval object
// from the given value provided as v.
func NewDayTimeInterval(v arrow.DayTimeInterval) DayTimeInterval {
	return DayTimeInterval(v)
}

// DayTimeInterval has logic to apply to this type.
type DayTimeInterval arrow.DayTimeInterval

// Value returns the underlying value in it's native type.
func (e DayTimeInterval) Value() arrow.DayTimeInterval {
	return arrow.DayTimeInterval(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e DayTimeInterval) compareTypes(r Object, f func(arrow.DayTimeInterval, arrow.DayTimeInterval) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case DayTimeInterval:
		return f(e.Value(), right.Value()), nil
	case *DayTimeInterval:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.DayTimeInterval", r, r)
	}
}

// Comparation methods

// Eq returns true if the left DayTimeInterval is equal to the right DayTimeInterval.
func (e DayTimeInterval) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.DayTimeInterval) Boolean {
		return Boolean(left.Days == right.Days && left.Milliseconds == right.Milliseconds)
	})
}

// Neq returns true if the left DayTimeInterval
// is not equal to the right DayTimeInterval.
func (e DayTimeInterval) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left DayTimeInterval
// is less than the right DayTimeInterval.
func (e DayTimeInterval) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.DayTimeInterval) Boolean {
		return Boolean(left.Days < right.Days && left.Milliseconds < right.Milliseconds)
	})
}

// LessEq returns true if the left DayTimeInterval
// is less than or equal to the right DayTimeInterval.
func (e DayTimeInterval) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.DayTimeInterval) Boolean {
		return Boolean(left.Days <= right.Days && left.Milliseconds <= right.Milliseconds)
	})
}

// Greater returns true if the left DayTimeInterval
// is greter than the right DayTimeInterval.
func (e DayTimeInterval) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.DayTimeInterval) Boolean {
		return Boolean(left.Days > right.Days && left.Milliseconds > right.Milliseconds)
	})
}

// GreaterEq returns true if the left DayTimeInterval
// is greter than or equal to the right DayTimeInterval.
func (e DayTimeInterval) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.DayTimeInterval) Boolean {
		return Boolean(left.Days >= right.Days && left.Milliseconds >= right.Milliseconds)
	})
}

// ToBooleanChecked attempts to cast the DayTimeInterval to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t DayTimeInterval) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the DayTimeInterval to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t DayTimeInterval) ToBoolean() Boolean {
	return Boolean(t.Days != 0 || t.Milliseconds != 0)
}

// ToDayTimeIntervalChecked attempts to cast the DayTimeInterval to a DayTimeInterval.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t DayTimeInterval) ToDayTimeIntervalChecked() (DayTimeInterval, Boolean) {
	return t.ToDayTimeInterval(), true
}

// ToDayTimeInterval attempts to cast the DayTimeInterval to a DayTimeInterval.
// The result is not checked for an overflow.
// Use the ToDayTimeIntervalChecked version of this method if you need to check for
// an overflow.
func (t DayTimeInterval) ToDayTimeInterval() DayTimeInterval {
	return t
}

// ToStringChecked attempts to cast the DayTimeInterval to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t DayTimeInterval) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the DayTimeInterval to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t DayTimeInterval) ToString() String {
	return String(fmt.Sprintf("%#v", t))
}

type CastableToDecimal128 interface {
	ToDecimal128Checked() (Decimal128, Boolean)
	ToDecimal128() Decimal128
}

// CastToDecimal128 takes an interface{} type or any Object type and
// attempts to convert it to the Decimal128 Object type.
func CastToDecimal128(v interface{}) (Decimal128, bool) {
	switch pt := v.(type) {
	case *Decimal128:
		return *pt, true
	case Decimal128:
		return pt, true
	case *decimal128.Num:
		t := *pt
		return Decimal128(t), true
	case decimal128.Num:
		t := pt
		return Decimal128(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Decimal128 {
			if t {
				return NewDecimal128FromU64(1)
			}
			return NewDecimal128FromU64(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Decimal128 {
			if t {
				return NewDecimal128FromU64(1)
			}
			return NewDecimal128FromU64(0)
		}(t), true
	case *Int64:
		t := *pt
		return Decimal128(decimal128.FromI64(int64(t))), true
	case Int64:
		t := pt
		return Decimal128(decimal128.FromI64(int64(t))), true
	case *Uint64:
		t := *pt
		return Decimal128(decimal128.FromU64(uint64(t))), true
	case Uint64:
		t := pt
		return Decimal128(decimal128.FromU64(uint64(t))), true
	default:
		// Also handles when v is nil
		return Decimal128(decimal128.New(0, 0)), false
	}
}

// NewDecimal128 creates a new Decimal128 object
// from the given value provided as v.
func NewDecimal128(v decimal128.Num) Decimal128 {
	return Decimal128(v)
}

// Decimal128 has logic to apply to this type.
type Decimal128 decimal128.Num

// Value returns the underlying value in it's native type.
func (e Decimal128) Value() decimal128.Num {
	return decimal128.Num(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Decimal128) compareTypes(r Object, f func(decimal128.Num, decimal128.Num) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Decimal128:
		return f(e.Value(), right.Value()), nil
	case *Decimal128:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Decimal128", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Decimal128 is equal to the right Decimal128.
func (e Decimal128) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right decimal128.Num) Boolean {
		return Boolean(left.HighBits() == right.HighBits() && left.LowBits() == right.LowBits())
	})
}

// Neq returns true if the left Decimal128
// is not equal to the right Decimal128.
func (e Decimal128) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Decimal128
// is less than the right Decimal128.
func (e Decimal128) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right decimal128.Num) Boolean {
		return Boolean(left.HighBits() < right.HighBits() || (left.HighBits() == right.HighBits() && left.LowBits() < right.LowBits()))
	})
}

// LessEq returns true if the left Decimal128
// is less than or equal to the right Decimal128.
func (e Decimal128) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right decimal128.Num) Boolean {
		return Boolean(!(right.HighBits() < left.HighBits() || (right.HighBits() == left.HighBits() && right.LowBits() < left.LowBits())))
	})
}

// Greater returns true if the left Decimal128
// is greter than the right Decimal128.
func (e Decimal128) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right decimal128.Num) Boolean {
		return Boolean(right.HighBits() < left.HighBits() || (right.HighBits() == left.HighBits() && right.LowBits() < left.LowBits()))
	})
}

// GreaterEq returns true if the left Decimal128
// is greter than or equal to the right Decimal128.
func (e Decimal128) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right decimal128.Num) Boolean {
		return Boolean(!(left.HighBits() < right.HighBits() || (left.HighBits() == right.HighBits() && left.LowBits() < right.LowBits())))
	})
}

// ToBooleanChecked attempts to cast the Decimal128 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Decimal128 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToBoolean() Boolean {
	return Boolean(t.Sign() != 0)
}

// ToDate32Checked attempts to cast the Decimal128 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Decimal128 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToDate32() Date32 {
	return Date32(t.toI64())
}

// ToDate64Checked attempts to cast the Decimal128 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Decimal128 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToDate64() Date64 {
	return Date64(t.toI64())
}

// ToDecimal128Checked attempts to cast the Decimal128 to a Decimal128.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToDecimal128Checked() (Decimal128, Boolean) {
	return t.ToDecimal128(), true
}

// ToDecimal128 attempts to cast the Decimal128 to a Decimal128.
// The result is not checked for an overflow.
// Use the ToDecimal128Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToDecimal128() Decimal128 {
	return t
}

// ToFloat32Checked attempts to cast the Decimal128 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Decimal128 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToFloat32() Float32 {
	return Float32(t.toI64())
}

// ToFloat64Checked attempts to cast the Decimal128 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Decimal128 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToFloat64() Float64 {
	return Float64(t.toI64())
}

// ToInt16Checked attempts to cast the Decimal128 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Decimal128 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToInt16() Int16 {
	return Int16(t.toI64())
}

// ToInt64Checked attempts to cast the Decimal128 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToInt64Checked() (Int64, Boolean) {
	var converted Int64
	converted = Int64(t.toI64())
	v, err := converted.ToDecimal128().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt64 attempts to cast the Decimal128 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToInt64() Int64 {
	return Int64(t.toI64())
}

// ToInt8Checked attempts to cast the Decimal128 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Decimal128 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToInt8() Int8 {
	return Int8(t.toI64())
}

// ToStringChecked attempts to cast the Decimal128 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Decimal128 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToString() String {
	return String(fmt.Sprintf("%#v", t))
}

// ToTime32Checked attempts to cast the Decimal128 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Decimal128 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToTime32() Time32 {
	return Time32(t.toI64())
}

// ToTime64Checked attempts to cast the Decimal128 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Decimal128 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToTime64() Time64 {
	return Time64(t.toI64())
}

// ToTimestampChecked attempts to cast the Decimal128 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Decimal128 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToTimestamp() Timestamp {
	return Timestamp(t.toI64())
}

// ToUint16Checked attempts to cast the Decimal128 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Decimal128 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToUint16() Uint16 {
	return Uint16(t.toI64())
}

// ToUint32Checked attempts to cast the Decimal128 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Decimal128 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToUint32() Uint32 {
	return Uint32(t.toU64())
}

// ToUint64Checked attempts to cast the Decimal128 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToUint64Checked() (Uint64, Boolean) {
	var converted Uint64
	converted = Uint64(t.toU64())
	v, err := converted.ToDecimal128().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint64 attempts to cast the Decimal128 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToUint64() Uint64 {
	return Uint64(t.toU64())
}

// ToUint8Checked attempts to cast the Decimal128 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Decimal128) ToUint8Checked() (Uint8, Boolean) {
	return t.ToUint8(), true
}

// ToUint8 attempts to cast the Decimal128 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Decimal128) ToUint8() Uint8 {
	return Uint8(t.toI64())
}

type CastableToDuration interface {
	ToDurationChecked() (Duration, Boolean)
	ToDuration() Duration
}

// CastToDuration takes an interface{} type or any Object type and
// attempts to convert it to the Duration Object type.
func CastToDuration(v interface{}) (Duration, bool) {
	switch pt := v.(type) {
	case *Duration:
		return *pt, true
	case Duration:
		return pt, true
	case *arrow.Duration:
		t := *pt
		return Duration(t), true
	case arrow.Duration:
		t := pt
		return Duration(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Duration {
			if t {
				return Duration(1)
			}
			return Duration(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Duration {
			if t {
				return Duration(1)
			}
			return Duration(0)
		}(t), true
	case *Int64:
		t := *pt
		return Duration(arrow.Duration(t)), true
	case Int64:
		t := pt
		return Duration(arrow.Duration(t)), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewDuration creates a new Duration object
// from the given value provided as v.
func NewDuration(v arrow.Duration) Duration {
	return Duration(v)
}

// Duration has logic to apply to this type.
type Duration arrow.Duration

// Value returns the underlying value in it's native type.
func (e Duration) Value() arrow.Duration {
	return arrow.Duration(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Duration) compareTypes(r Object, f func(arrow.Duration, arrow.Duration) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Duration:
		return f(e.Value(), right.Value()), nil
	case *Duration:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Duration", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Duration is equal to the right Duration.
func (e Duration) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Duration) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Duration
// is not equal to the right Duration.
func (e Duration) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Duration
// is less than the right Duration.
func (e Duration) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Duration) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Duration
// is less than or equal to the right Duration.
func (e Duration) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Duration) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Duration
// is greter than the right Duration.
func (e Duration) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Duration) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Duration
// is greter than or equal to the right Duration.
func (e Duration) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Duration) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Duration to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Duration to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Duration) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Duration to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Duration to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Duration to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Duration to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToDate64() Date64 {
	return Date64(t)
}

// ToDurationChecked attempts to cast the Duration to a Duration.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToDurationChecked() (Duration, Boolean) {
	return t.ToDuration(), true
}

// ToDuration attempts to cast the Duration to a Duration.
// The result is not checked for an overflow.
// Use the ToDurationChecked version of this method if you need to check for
// an overflow.
func (t Duration) ToDuration() Duration {
	return t
}

// ToFloat32Checked attempts to cast the Duration to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Duration to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Duration to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Duration to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Duration to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Duration to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToInt16() Int16 {
	return Int16(t)
}

// ToInt64Checked attempts to cast the Duration to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Duration to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Duration to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Duration to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Duration to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Duration to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Duration) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Duration to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Duration to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Duration to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Duration to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Duration to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Duration to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Duration) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Duration to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Duration to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Duration to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Duration to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Duration to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Duration to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Duration to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Duration) ToUint8Checked() (Uint8, Boolean) {
	return t.ToUint8(), true
}

// ToUint8 attempts to cast the Duration to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Duration) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToFloat16 interface {
	ToFloat16Checked() (Float16, Boolean)
	ToFloat16() Float16
}

// CastToFloat16 takes an interface{} type or any Object type and
// attempts to convert it to the Float16 Object type.
func CastToFloat16(v interface{}) (Float16, bool) {
	switch pt := v.(type) {
	case *Float16:
		return *pt, true
	case Float16:
		return pt, true
	case *float16.Num:
		t := *pt
		return Float16(t), true
	case float16.Num:
		t := pt
		return Float16(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Float16 {
			if t {
				return Float16(float16.New(1))
			}
			return Float16(float16.New(0))
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Float16 {
			if t {
				return Float16(float16.New(1))
			}
			return Float16(float16.New(0))
		}(t), true
	case *Float32:
		t := *pt
		return Float16(float16.New(float32(t))), true
	case Float32:
		t := pt
		return Float16(float16.New(float32(t))), true
	default:
		// Also handles when v is nil
		return Float16(float16.New(0)), false
	}
}

// NewFloat16 creates a new Float16 object
// from the given value provided as v.
func NewFloat16(v float16.Num) Float16 {
	return Float16(v)
}

// Float16 has logic to apply to this type.
type Float16 float16.Num

// Value returns the underlying value in it's native type.
func (e Float16) Value() float16.Num {
	return float16.Num(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Float16) compareTypes(r Object, f func(float16.Num, float16.Num) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Float16:
		return f(e.Value(), right.Value()), nil
	case *Float16:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Float16", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Float16 is equal to the right Float16.
func (e Float16) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float16.Num) Boolean {
		return Boolean(left.Uint16() == right.Uint16())
	})
}

// Neq returns true if the left Float16
// is not equal to the right Float16.
func (e Float16) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Float16
// is less than the right Float16.
func (e Float16) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float16.Num) Boolean {
		return Boolean(left.Uint16() < right.Uint16())
	})
}

// LessEq returns true if the left Float16
// is less than or equal to the right Float16.
func (e Float16) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float16.Num) Boolean {
		return Boolean(left.Uint16() <= right.Uint16())
	})
}

// Greater returns true if the left Float16
// is greter than the right Float16.
func (e Float16) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float16.Num) Boolean {
		return Boolean(left.Uint16() > right.Uint16())
	})
}

// GreaterEq returns true if the left Float16
// is greter than or equal to the right Float16.
func (e Float16) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float16.Num) Boolean {
		return Boolean(left.Uint16() >= right.Uint16())
	})
}

// ToBooleanChecked attempts to cast the Float16 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Float16 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Float16) ToBoolean() Boolean {
	return Boolean(t.Uint16() != 0)
}

// ToDate32Checked attempts to cast the Float16 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Float16 to a Date32.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToDate32() Date32 {
	return Date32(t.tof32())
}

// ToDate64Checked attempts to cast the Float16 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Float16 to a Date64.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToDate64() Date64 {
	return Date64(t.tof32())
}

// ToFloat16Checked attempts to cast the Float16 to a Float16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToFloat16Checked() (Float16, Boolean) {
	return t.ToFloat16(), true
}

// ToFloat16 attempts to cast the Float16 to a Float16.
// The result is not checked for an overflow.
// Use the ToFloat16Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToFloat16() Float16 {
	return t
}

// ToFloat32Checked attempts to cast the Float16 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Float16 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToFloat32() Float32 {
	return Float32(t.tof32())
}

// ToFloat64Checked attempts to cast the Float16 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Float16 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToFloat64() Float64 {
	return Float64(t.tof32())
}

// ToInt16Checked attempts to cast the Float16 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Float16 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToInt16() Int16 {
	return Int16(t.tof32())
}

// ToInt32Checked attempts to cast the Float16 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Float16 to a Int32.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToInt32() Int32 {
	return Int32(t.tof32())
}

// ToInt64Checked attempts to cast the Float16 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Float16 to a Int64.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToInt64() Int64 {
	return Int64(t.tof32())
}

// ToInt8Checked attempts to cast the Float16 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Float16 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToInt8() Int8 {
	return Int8(t.tof32())
}

// ToStringChecked attempts to cast the Float16 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Float16 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Float16) ToString() String {
	return String(fmt.Sprintf("%#v", t))
}

// ToTime32Checked attempts to cast the Float16 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Float16 to a Time32.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToTime32() Time32 {
	return Time32(t.tof32())
}

// ToTime64Checked attempts to cast the Float16 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Float16 to a Time64.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToTime64() Time64 {
	return Time64(t.tof32())
}

// ToTimestampChecked attempts to cast the Float16 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Float16 to a Timestamp.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Float16) ToTimestamp() Timestamp {
	return Timestamp(t.tof32())
}

// ToUint16Checked attempts to cast the Float16 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Float16 to a Uint16.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToUint16() Uint16 {
	return Uint16(t.tof32())
}

// ToUint32Checked attempts to cast the Float16 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Float16 to a Uint32.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToUint32() Uint32 {
	return Uint32(t.tof32())
}

// ToUint64Checked attempts to cast the Float16 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float16) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Float16 to a Uint64.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToUint64() Uint64 {
	return Uint64(t.tof32())
}

// ToUint8Checked attempts to cast the Float16 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float16) ToUint8Checked() (Uint8, Boolean) {
	return t.ToUint8(), true
}

// ToUint8 attempts to cast the Float16 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Float16) ToUint8() Uint8 {
	return Uint8(t.tof32())
}

type CastableToFloat32 interface {
	ToFloat32Checked() (Float32, Boolean)
	ToFloat32() Float32
}

// CastToFloat32 takes an interface{} type or any Object type and
// attempts to convert it to the Float32 Object type.
func CastToFloat32(v interface{}) (Float32, bool) {
	switch pt := v.(type) {
	case *Float32:
		return *pt, true
	case Float32:
		return pt, true
	case *float32:
		t := *pt
		return Float32(t), true
	case float32:
		t := pt
		return Float32(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Float32 {
			if t {
				return Float32(1)
			}
			return Float32(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Float32 {
			if t {
				return Float32(1)
			}
			return Float32(0)
		}(t), true
	case *Date64:
		t := *pt
		return Float32(t), true
	case Date64:
		t := pt
		return Float32(t), true
	case *Decimal128:
		t := *pt
		return Float32(t.toI64()), true
	case Decimal128:
		t := pt
		return Float32(t.toI64()), true
	case *Duration:
		t := *pt
		return Float32(t), true
	case Duration:
		t := pt
		return Float32(t), true
	case *Float16:
		t := *pt
		return Float32(t.tof32()), true
	case Float16:
		t := pt
		return Float32(t.tof32()), true
	case *Float64:
		t := *pt
		return Float32(t), true
	case Float64:
		t := pt
		return Float32(t), true
	case *Int16:
		t := *pt
		return Float32(t), true
	case Int16:
		t := pt
		return Float32(t), true
	case *Int32:
		t := *pt
		return Float32(t), true
	case Int32:
		t := pt
		return Float32(t), true
	case *Int64:
		t := *pt
		return Float32(t), true
	case Int64:
		t := pt
		return Float32(t), true
	case *Int8:
		t := *pt
		return Float32(t), true
	case Int8:
		t := pt
		return Float32(t), true
	case *Time32:
		t := *pt
		return Float32(t), true
	case Time32:
		t := pt
		return Float32(t), true
	case *Time64:
		t := *pt
		return Float32(t), true
	case Time64:
		t := pt
		return Float32(t), true
	case *Timestamp:
		t := *pt
		return Float32(t), true
	case Timestamp:
		t := pt
		return Float32(t), true
	case *Uint16:
		t := *pt
		return Float32(t), true
	case Uint16:
		t := pt
		return Float32(t), true
	case *Uint32:
		t := *pt
		return Float32(t), true
	case Uint32:
		t := pt
		return Float32(t), true
	case *Uint64:
		t := *pt
		return Float32(t), true
	case Uint64:
		t := pt
		return Float32(t), true
	case *Uint8:
		t := *pt
		return Float32(t), true
	case Uint8:
		t := pt
		return Float32(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewFloat32 creates a new Float32 object
// from the given value provided as v.
func NewFloat32(v float32) Float32 {
	return Float32(v)
}

// Float32 has logic to apply to this type.
type Float32 float32

// Value returns the underlying value in it's native type.
func (e Float32) Value() float32 {
	return float32(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Float32) compareTypes(r Object, f func(float32, float32) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Float32:
		return f(e.Value(), right.Value()), nil
	case *Float32:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Float32", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Float32 is equal to the right Float32.
func (e Float32) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float32) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Float32
// is not equal to the right Float32.
func (e Float32) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Float32
// is less than the right Float32.
func (e Float32) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float32) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Float32
// is less than or equal to the right Float32.
func (e Float32) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float32) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Float32
// is greter than the right Float32.
func (e Float32) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float32) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Float32
// is greter than or equal to the right Float32.
func (e Float32) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float32) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Float32 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Float32 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Float32) ToBoolean() Boolean {
	return Boolean(t != 0.0)
}

// ToDate32Checked attempts to cast the Float32 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Float32 to a Date32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Float32 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToDate64Checked() (Date64, Boolean) {
	var converted Date64
	converted = Date64(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToDate64 attempts to cast the Float32 to a Date64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat16Checked attempts to cast the Float32 to a Float16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToFloat16Checked() (Float16, Boolean) {
	var converted Float16
	converted = Float16(float16.New(float32(t)))
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToFloat16 attempts to cast the Float32 to a Float16.
// The result is not checked for an overflow.
// Use the ToFloat16Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToFloat16() Float16 {
	return Float16(float16.New(float32(t)))
}

// ToFloat32Checked attempts to cast the Float32 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Float32 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToFloat32() Float32 {
	return t
}

// ToFloat64Checked attempts to cast the Float32 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Float32 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Float32 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Float32 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Float32 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToInt32Checked() (Int32, Boolean) {
	var converted Int32
	converted = Int32(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt32 attempts to cast the Float32 to a Int32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Float32 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToInt64Checked() (Int64, Boolean) {
	var converted Int64
	converted = Int64(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt64 attempts to cast the Float32 to a Int64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Float32 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Float32 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Float32 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Float32 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Float32) ToString() String {
	return String(fmt.Sprintf("%g", t))
}

// ToTime32Checked attempts to cast the Float32 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToTime32Checked() (Time32, Boolean) {
	var converted Time32
	converted = Time32(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime32 attempts to cast the Float32 to a Time32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Float32 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToTime64Checked() (Time64, Boolean) {
	var converted Time64
	converted = Time64(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime64 attempts to cast the Float32 to a Time64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Float32 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToTimestampChecked() (Timestamp, Boolean) {
	var converted Timestamp
	converted = Timestamp(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTimestamp attempts to cast the Float32 to a Timestamp.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Float32) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Float32 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Float32 to a Uint16.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Float32 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToUint32Checked() (Uint32, Boolean) {
	var converted Uint32
	converted = Uint32(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint32 attempts to cast the Float32 to a Uint32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Float32 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float32) ToUint64Checked() (Uint64, Boolean) {
	var converted Uint64
	converted = Uint64(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint64 attempts to cast the Float32 to a Uint64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Float32 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float32) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToFloat32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Float32 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Float32) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToFloat64 interface {
	ToFloat64Checked() (Float64, Boolean)
	ToFloat64() Float64
}

// CastToFloat64 takes an interface{} type or any Object type and
// attempts to convert it to the Float64 Object type.
func CastToFloat64(v interface{}) (Float64, bool) {
	switch pt := v.(type) {
	case *Float64:
		return *pt, true
	case Float64:
		return pt, true
	case *float64:
		t := *pt
		return Float64(t), true
	case float64:
		t := pt
		return Float64(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Float64 {
			if t {
				return Float64(1)
			}
			return Float64(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Float64 {
			if t {
				return Float64(1)
			}
			return Float64(0)
		}(t), true
	case *Date64:
		t := *pt
		return Float64(t), true
	case Date64:
		t := pt
		return Float64(t), true
	case *Decimal128:
		t := *pt
		return Float64(t.toI64()), true
	case Decimal128:
		t := pt
		return Float64(t.toI64()), true
	case *Duration:
		t := *pt
		return Float64(t), true
	case Duration:
		t := pt
		return Float64(t), true
	case *Float16:
		t := *pt
		return Float64(t.tof32()), true
	case Float16:
		t := pt
		return Float64(t.tof32()), true
	case *Float32:
		t := *pt
		return Float64(t), true
	case Float32:
		t := pt
		return Float64(t), true
	case *Int16:
		t := *pt
		return Float64(t), true
	case Int16:
		t := pt
		return Float64(t), true
	case *Int32:
		t := *pt
		return Float64(t), true
	case Int32:
		t := pt
		return Float64(t), true
	case *Int64:
		t := *pt
		return Float64(t), true
	case Int64:
		t := pt
		return Float64(t), true
	case *Int8:
		t := *pt
		return Float64(t), true
	case Int8:
		t := pt
		return Float64(t), true
	case *Time32:
		t := *pt
		return Float64(t), true
	case Time32:
		t := pt
		return Float64(t), true
	case *Time64:
		t := *pt
		return Float64(t), true
	case Time64:
		t := pt
		return Float64(t), true
	case *Timestamp:
		t := *pt
		return Float64(t), true
	case Timestamp:
		t := pt
		return Float64(t), true
	case *Uint16:
		t := *pt
		return Float64(t), true
	case Uint16:
		t := pt
		return Float64(t), true
	case *Uint32:
		t := *pt
		return Float64(t), true
	case Uint32:
		t := pt
		return Float64(t), true
	case *Uint64:
		t := *pt
		return Float64(t), true
	case Uint64:
		t := pt
		return Float64(t), true
	case *Uint8:
		t := *pt
		return Float64(t), true
	case Uint8:
		t := pt
		return Float64(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewFloat64 creates a new Float64 object
// from the given value provided as v.
func NewFloat64(v float64) Float64 {
	return Float64(v)
}

// Float64 has logic to apply to this type.
type Float64 float64

// Value returns the underlying value in it's native type.
func (e Float64) Value() float64 {
	return float64(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Float64) compareTypes(r Object, f func(float64, float64) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Float64:
		return f(e.Value(), right.Value()), nil
	case *Float64:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Float64", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Float64 is equal to the right Float64.
func (e Float64) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float64) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Float64
// is not equal to the right Float64.
func (e Float64) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Float64
// is less than the right Float64.
func (e Float64) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float64) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Float64
// is less than or equal to the right Float64.
func (e Float64) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float64) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Float64
// is greter than the right Float64.
func (e Float64) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float64) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Float64
// is greter than or equal to the right Float64.
func (e Float64) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right float64) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Float64 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float64) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Float64 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Float64) ToBoolean() Boolean {
	return Boolean(t != 0.0)
}

// ToDate32Checked attempts to cast the Float64 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Float64 to a Date32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Float64 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToDate64Checked() (Date64, Boolean) {
	var converted Date64
	converted = Date64(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToDate64 attempts to cast the Float64 to a Date64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Float64 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float64) ToFloat32Checked() (Float32, Boolean) {
	var converted Float32
	converted = Float32(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToFloat32 attempts to cast the Float64 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Float64 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float64) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Float64 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToFloat64() Float64 {
	return t
}

// ToInt16Checked attempts to cast the Float64 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Float64 to a Int16.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Float64 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToInt32Checked() (Int32, Boolean) {
	var converted Int32
	converted = Int32(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt32 attempts to cast the Float64 to a Int32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Float64 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToInt64Checked() (Int64, Boolean) {
	var converted Int64
	converted = Int64(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt64 attempts to cast the Float64 to a Int64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Float64 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float64) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Float64 to a Int8.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Float64 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Float64) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Float64 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Float64) ToString() String {
	return String(fmt.Sprintf("%g", t))
}

// ToTime32Checked attempts to cast the Float64 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToTime32Checked() (Time32, Boolean) {
	var converted Time32
	converted = Time32(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime32 attempts to cast the Float64 to a Time32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Float64 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToTime64Checked() (Time64, Boolean) {
	var converted Time64
	converted = Time64(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime64 attempts to cast the Float64 to a Time64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Float64 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToTimestampChecked() (Timestamp, Boolean) {
	var converted Timestamp
	converted = Timestamp(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTimestamp attempts to cast the Float64 to a Timestamp.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Float64) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Float64 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Float64 to a Uint16.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Float64 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToUint32Checked() (Uint32, Boolean) {
	var converted Uint32
	converted = Uint32(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint32 attempts to cast the Float64 to a Uint32.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Float64 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 123.567 => 123
func (t Float64) ToUint64Checked() (Uint64, Boolean) {
	var converted Uint64
	converted = Uint64(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint64 attempts to cast the Float64 to a Uint64.
// The result is not checked for an overflow.
// The result will be truncated. 123.567 => 123
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Float64 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
// The result will be truncated. 3.5 => 3
func (t Float64) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToFloat64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Float64 to a Uint8.
// The result is not checked for an overflow.
// The result will be truncated. 3.5 => 3
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Float64) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToInt16 interface {
	ToInt16Checked() (Int16, Boolean)
	ToInt16() Int16
}

// CastToInt16 takes an interface{} type or any Object type and
// attempts to convert it to the Int16 Object type.
func CastToInt16(v interface{}) (Int16, bool) {
	switch pt := v.(type) {
	case *Int16:
		return *pt, true
	case Int16:
		return pt, true
	case *int16:
		t := *pt
		return Int16(t), true
	case int16:
		t := pt
		return Int16(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Int16 {
			if t {
				return Int16(1)
			}
			return Int16(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Int16 {
			if t {
				return Int16(1)
			}
			return Int16(0)
		}(t), true
	case *Date64:
		t := *pt
		return Int16(t), true
	case Date64:
		t := pt
		return Int16(t), true
	case *Decimal128:
		t := *pt
		return Int16(t.toI64()), true
	case Decimal128:
		t := pt
		return Int16(t.toI64()), true
	case *Duration:
		t := *pt
		return Int16(t), true
	case Duration:
		t := pt
		return Int16(t), true
	case *Float16:
		t := *pt
		return Int16(t.tof32()), true
	case Float16:
		t := pt
		return Int16(t.tof32()), true
	case *Float32:
		t := *pt
		return Int16(t), true
	case Float32:
		t := pt
		return Int16(t), true
	case *Float64:
		t := *pt
		return Int16(t), true
	case Float64:
		t := pt
		return Int16(t), true
	case *Int32:
		t := *pt
		return Int16(t), true
	case Int32:
		t := pt
		return Int16(t), true
	case *Int64:
		t := *pt
		return Int16(t), true
	case Int64:
		t := pt
		return Int16(t), true
	case *Int8:
		t := *pt
		return Int16(t), true
	case Int8:
		t := pt
		return Int16(t), true
	case *Time32:
		t := *pt
		return Int16(t), true
	case Time32:
		t := pt
		return Int16(t), true
	case *Time64:
		t := *pt
		return Int16(t), true
	case Time64:
		t := pt
		return Int16(t), true
	case *Timestamp:
		t := *pt
		return Int16(t), true
	case Timestamp:
		t := pt
		return Int16(t), true
	case *Uint16:
		t := *pt
		return Int16(t), true
	case Uint16:
		t := pt
		return Int16(t), true
	case *Uint32:
		t := *pt
		return Int16(t), true
	case Uint32:
		t := pt
		return Int16(t), true
	case *Uint64:
		t := *pt
		return Int16(t), true
	case Uint64:
		t := pt
		return Int16(t), true
	case *Uint8:
		t := *pt
		return Int16(t), true
	case Uint8:
		t := pt
		return Int16(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewInt16 creates a new Int16 object
// from the given value provided as v.
func NewInt16(v int16) Int16 {
	return Int16(v)
}

// Int16 has logic to apply to this type.
type Int16 int16

// Value returns the underlying value in it's native type.
func (e Int16) Value() int16 {
	return int16(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Int16) compareTypes(r Object, f func(int16, int16) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Int16:
		return f(e.Value(), right.Value()), nil
	case *Int16:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Int16", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Int16 is equal to the right Int16.
func (e Int16) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int16) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Int16
// is not equal to the right Int16.
func (e Int16) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Int16
// is less than the right Int16.
func (e Int16) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int16) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Int16
// is less than or equal to the right Int16.
func (e Int16) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int16) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Int16
// is greter than the right Int16.
func (e Int16) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int16) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Int16
// is greter than or equal to the right Int16.
func (e Int16) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int16) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Int16 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Int16 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Int16) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Int16 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Int16 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Int16 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Int16 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Int16 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Int16 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Int16 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Int16 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Int16 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Int16 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToInt16() Int16 {
	return t
}

// ToInt32Checked attempts to cast the Int16 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Int16 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Int16 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Int16 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Int16 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToInt16().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Int16 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Int16 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Int16 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Int16) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Int16 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Int16 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Int16 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Int16 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Int16 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Int16 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Int16) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Int16 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Int16 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Int16 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Int16 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Int16 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Int16 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Int16 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int16) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToInt16().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Int16 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Int16) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToInt32 interface {
	ToInt32Checked() (Int32, Boolean)
	ToInt32() Int32
}

// CastToInt32 takes an interface{} type or any Object type and
// attempts to convert it to the Int32 Object type.
func CastToInt32(v interface{}) (Int32, bool) {
	switch pt := v.(type) {
	case *Int32:
		return *pt, true
	case Int32:
		return pt, true
	case *int32:
		t := *pt
		return Int32(t), true
	case int32:
		t := pt
		return Int32(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Int32 {
			if t {
				return Int32(1)
			}
			return Int32(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Int32 {
			if t {
				return Int32(1)
			}
			return Int32(0)
		}(t), true
	case *Date32:
		t := *pt
		return Int32(t), true
	case Date32:
		t := pt
		return Int32(t), true
	case *Date64:
		t := *pt
		return Int32(t), true
	case Date64:
		t := pt
		return Int32(t), true
	case *Float16:
		t := *pt
		return Int32(t.tof32()), true
	case Float16:
		t := pt
		return Int32(t.tof32()), true
	case *Float32:
		t := *pt
		return Int32(t), true
	case Float32:
		t := pt
		return Int32(t), true
	case *Float64:
		t := *pt
		return Int32(t), true
	case Float64:
		t := pt
		return Int32(t), true
	case *Int16:
		t := *pt
		return Int32(t), true
	case Int16:
		t := pt
		return Int32(t), true
	case *Int64:
		t := *pt
		return Int32(t), true
	case Int64:
		t := pt
		return Int32(t), true
	case *Int8:
		t := *pt
		return Int32(t), true
	case Int8:
		t := pt
		return Int32(t), true
	case *MonthInterval:
		t := *pt
		return Int32(t), true
	case MonthInterval:
		t := pt
		return Int32(t), true
	case *Time32:
		t := *pt
		return Int32(t), true
	case Time32:
		t := pt
		return Int32(t), true
	case *Time64:
		t := *pt
		return Int32(t), true
	case Time64:
		t := pt
		return Int32(t), true
	case *Timestamp:
		t := *pt
		return Int32(t), true
	case Timestamp:
		t := pt
		return Int32(t), true
	case *Uint16:
		t := *pt
		return Int32(t), true
	case Uint16:
		t := pt
		return Int32(t), true
	case *Uint32:
		t := *pt
		return Int32(t), true
	case Uint32:
		t := pt
		return Int32(t), true
	case *Uint64:
		t := *pt
		return Int32(t), true
	case Uint64:
		t := pt
		return Int32(t), true
	case *Uint8:
		t := *pt
		return Int32(t), true
	case Uint8:
		t := pt
		return Int32(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewInt32 creates a new Int32 object
// from the given value provided as v.
func NewInt32(v int32) Int32 {
	return Int32(v)
}

// Int32 has logic to apply to this type.
type Int32 int32

// Value returns the underlying value in it's native type.
func (e Int32) Value() int32 {
	return int32(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Int32) compareTypes(r Object, f func(int32, int32) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Int32:
		return f(e.Value(), right.Value()), nil
	case *Int32:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Int32", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Int32 is equal to the right Int32.
func (e Int32) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int32) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Int32
// is not equal to the right Int32.
func (e Int32) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Int32
// is less than the right Int32.
func (e Int32) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int32) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Int32
// is less than or equal to the right Int32.
func (e Int32) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int32) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Int32
// is greter than the right Int32.
func (e Int32) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int32) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Int32
// is greter than or equal to the right Int32.
func (e Int32) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int32) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Int32 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Int32 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Int32) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Int32 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Int32 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Int32 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Int32 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Int32 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Int32 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Int32 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Int32 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Int32 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToInt32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Int32 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Int32 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Int32 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToInt32() Int32 {
	return t
}

// ToInt64Checked attempts to cast the Int32 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Int32 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Int32 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToInt32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Int32 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToInt8() Int8 {
	return Int8(t)
}

// ToMonthIntervalChecked attempts to cast the Int32 to a MonthInterval.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToMonthIntervalChecked() (MonthInterval, Boolean) {
	return t.ToMonthInterval(), true
}

// ToMonthInterval attempts to cast the Int32 to a MonthInterval.
// The result is not checked for an overflow.
// Use the ToMonthIntervalChecked version of this method if you need to check for
// an overflow.
func (t Int32) ToMonthInterval() MonthInterval {
	return MonthInterval(arrow.MonthInterval(int32(t)))
}

// ToStringChecked attempts to cast the Int32 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Int32 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Int32) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Int32 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Int32 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Int32 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Int32 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Int32 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Int32 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Int32) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Int32 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToInt32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Int32 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Int32 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Int32 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Int32 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Int32 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Int32 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int32) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToInt32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Int32 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Int32) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToInt64 interface {
	ToInt64Checked() (Int64, Boolean)
	ToInt64() Int64
}

// CastToInt64 takes an interface{} type or any Object type and
// attempts to convert it to the Int64 Object type.
func CastToInt64(v interface{}) (Int64, bool) {
	switch pt := v.(type) {
	case *Int64:
		return *pt, true
	case Int64:
		return pt, true
	case *int64:
		t := *pt
		return Int64(t), true
	case int64:
		t := pt
		return Int64(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Int64 {
			if t {
				return Int64(1)
			}
			return Int64(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Int64 {
			if t {
				return Int64(1)
			}
			return Int64(0)
		}(t), true
	case *Date32:
		t := *pt
		return Int64(t), true
	case Date32:
		t := pt
		return Int64(t), true
	case *Date64:
		t := *pt
		return Int64(t), true
	case Date64:
		t := pt
		return Int64(t), true
	case *Decimal128:
		t := *pt
		return Int64(t.toI64()), true
	case Decimal128:
		t := pt
		return Int64(t.toI64()), true
	case *Duration:
		t := *pt
		return Int64(t), true
	case Duration:
		t := pt
		return Int64(t), true
	case *Float16:
		t := *pt
		return Int64(t.tof32()), true
	case Float16:
		t := pt
		return Int64(t.tof32()), true
	case *Float32:
		t := *pt
		return Int64(t), true
	case Float32:
		t := pt
		return Int64(t), true
	case *Float64:
		t := *pt
		return Int64(t), true
	case Float64:
		t := pt
		return Int64(t), true
	case *Int16:
		t := *pt
		return Int64(t), true
	case Int16:
		t := pt
		return Int64(t), true
	case *Int32:
		t := *pt
		return Int64(t), true
	case Int32:
		t := pt
		return Int64(t), true
	case *Int8:
		t := *pt
		return Int64(t), true
	case Int8:
		t := pt
		return Int64(t), true
	case *Time32:
		t := *pt
		return Int64(t), true
	case Time32:
		t := pt
		return Int64(t), true
	case *Time64:
		t := *pt
		return Int64(t), true
	case Time64:
		t := pt
		return Int64(t), true
	case *Timestamp:
		t := *pt
		return Int64(t), true
	case Timestamp:
		t := pt
		return Int64(t), true
	case *Uint16:
		t := *pt
		return Int64(t), true
	case Uint16:
		t := pt
		return Int64(t), true
	case *Uint32:
		t := *pt
		return Int64(t), true
	case Uint32:
		t := pt
		return Int64(t), true
	case *Uint64:
		t := *pt
		return Int64(t), true
	case Uint64:
		t := pt
		return Int64(t), true
	case *Uint8:
		t := *pt
		return Int64(t), true
	case Uint8:
		t := pt
		return Int64(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewInt64 creates a new Int64 object
// from the given value provided as v.
func NewInt64(v int64) Int64 {
	return Int64(v)
}

// Int64 has logic to apply to this type.
type Int64 int64

// Value returns the underlying value in it's native type.
func (e Int64) Value() int64 {
	return int64(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Int64) compareTypes(r Object, f func(int64, int64) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Int64:
		return f(e.Value(), right.Value()), nil
	case *Int64:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Int64", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Int64 is equal to the right Int64.
func (e Int64) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int64) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Int64
// is not equal to the right Int64.
func (e Int64) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Int64
// is less than the right Int64.
func (e Int64) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int64) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Int64
// is less than or equal to the right Int64.
func (e Int64) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int64) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Int64
// is greter than the right Int64.
func (e Int64) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int64) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Int64
// is greter than or equal to the right Int64.
func (e Int64) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int64) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Int64 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Int64 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Int64) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Int64 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToDate32Checked() (Date32, Boolean) {
	var converted Date32
	converted = Date32(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToDate32 attempts to cast the Int64 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Int64 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Int64 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToDate64() Date64 {
	return Date64(t)
}

// ToDecimal128Checked attempts to cast the Int64 to a Decimal128.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToDecimal128Checked() (Decimal128, Boolean) {
	return t.ToDecimal128(), true
}

// ToDecimal128 attempts to cast the Int64 to a Decimal128.
// The result is not checked for an overflow.
// Use the ToDecimal128Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToDecimal128() Decimal128 {
	return Decimal128(decimal128.FromI64(int64(t)))
}

// ToDurationChecked attempts to cast the Int64 to a Duration.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToDurationChecked() (Duration, Boolean) {
	return t.ToDuration(), true
}

// ToDuration attempts to cast the Int64 to a Duration.
// The result is not checked for an overflow.
// Use the ToDurationChecked version of this method if you need to check for
// an overflow.
func (t Int64) ToDuration() Duration {
	return Duration(arrow.Duration(t))
}

// ToFloat32Checked attempts to cast the Int64 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Int64 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Int64 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Int64 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Int64 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Int64 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Int64 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToInt32Checked() (Int32, Boolean) {
	var converted Int32
	converted = Int32(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt32 attempts to cast the Int64 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Int64 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Int64 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToInt64() Int64 {
	return t
}

// ToInt8Checked attempts to cast the Int64 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Int64 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Int64 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Int64 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Int64) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Int64 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToTime32Checked() (Time32, Boolean) {
	var converted Time32
	converted = Time32(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime32 attempts to cast the Int64 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Int64 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Int64 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Int64 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Int64 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Int64) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Int64 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Int64 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Int64 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToUint32Checked() (Uint32, Boolean) {
	var converted Uint32
	converted = Uint32(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint32 attempts to cast the Int64 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Int64 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Int64 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Int64 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int64) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToInt64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Int64 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Int64) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToInt8 interface {
	ToInt8Checked() (Int8, Boolean)
	ToInt8() Int8
}

// CastToInt8 takes an interface{} type or any Object type and
// attempts to convert it to the Int8 Object type.
func CastToInt8(v interface{}) (Int8, bool) {
	switch pt := v.(type) {
	case *Int8:
		return *pt, true
	case Int8:
		return pt, true
	case *int8:
		t := *pt
		return Int8(t), true
	case int8:
		t := pt
		return Int8(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Int8 {
			if t {
				return Int8(1)
			}
			return Int8(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Int8 {
			if t {
				return Int8(1)
			}
			return Int8(0)
		}(t), true
	case *Date64:
		t := *pt
		return Int8(t), true
	case Date64:
		t := pt
		return Int8(t), true
	case *Decimal128:
		t := *pt
		return Int8(t.toI64()), true
	case Decimal128:
		t := pt
		return Int8(t.toI64()), true
	case *Duration:
		t := *pt
		return Int8(t), true
	case Duration:
		t := pt
		return Int8(t), true
	case *Float16:
		t := *pt
		return Int8(t.tof32()), true
	case Float16:
		t := pt
		return Int8(t.tof32()), true
	case *Float32:
		t := *pt
		return Int8(t), true
	case Float32:
		t := pt
		return Int8(t), true
	case *Float64:
		t := *pt
		return Int8(t), true
	case Float64:
		t := pt
		return Int8(t), true
	case *Int16:
		t := *pt
		return Int8(t), true
	case Int16:
		t := pt
		return Int8(t), true
	case *Int32:
		t := *pt
		return Int8(t), true
	case Int32:
		t := pt
		return Int8(t), true
	case *Int64:
		t := *pt
		return Int8(t), true
	case Int64:
		t := pt
		return Int8(t), true
	case *Time32:
		t := *pt
		return Int8(t), true
	case Time32:
		t := pt
		return Int8(t), true
	case *Time64:
		t := *pt
		return Int8(t), true
	case Time64:
		t := pt
		return Int8(t), true
	case *Timestamp:
		t := *pt
		return Int8(t), true
	case Timestamp:
		t := pt
		return Int8(t), true
	case *Uint16:
		t := *pt
		return Int8(t), true
	case Uint16:
		t := pt
		return Int8(t), true
	case *Uint32:
		t := *pt
		return Int8(t), true
	case Uint32:
		t := pt
		return Int8(t), true
	case *Uint64:
		t := *pt
		return Int8(t), true
	case Uint64:
		t := pt
		return Int8(t), true
	case *Uint8:
		t := *pt
		return Int8(t), true
	case Uint8:
		t := pt
		return Int8(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewInt8 creates a new Int8 object
// from the given value provided as v.
func NewInt8(v int8) Int8 {
	return Int8(v)
}

// Int8 has logic to apply to this type.
type Int8 int8

// Value returns the underlying value in it's native type.
func (e Int8) Value() int8 {
	return int8(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Int8) compareTypes(r Object, f func(int8, int8) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Int8:
		return f(e.Value(), right.Value()), nil
	case *Int8:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Int8", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Int8 is equal to the right Int8.
func (e Int8) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int8) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Int8
// is not equal to the right Int8.
func (e Int8) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Int8
// is less than the right Int8.
func (e Int8) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int8) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Int8
// is less than or equal to the right Int8.
func (e Int8) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int8) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Int8
// is greter than the right Int8.
func (e Int8) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int8) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Int8
// is greter than or equal to the right Int8.
func (e Int8) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right int8) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Int8 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Int8 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Int8) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Int8 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Int8 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Int8 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Int8 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Int8 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Int8 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Int8 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Int8 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Int8 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Int8 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Int8 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Int8 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Int8 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Int8 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Int8 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Int8 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToInt8() Int8 {
	return t
}

// ToStringChecked attempts to cast the Int8 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Int8 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Int8) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Int8 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Int8 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Int8 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Int8 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Int8 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Int8 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Int8) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Int8 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Int8 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Int8 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Int8 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Int8 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Int8 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Int8 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Int8) ToUint8Checked() (Uint8, Boolean) {
	return t.ToUint8(), true
}

// ToUint8 attempts to cast the Int8 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Int8) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToMonthInterval interface {
	ToMonthIntervalChecked() (MonthInterval, Boolean)
	ToMonthInterval() MonthInterval
}

// CastToMonthInterval takes an interface{} type or any Object type and
// attempts to convert it to the MonthInterval Object type.
func CastToMonthInterval(v interface{}) (MonthInterval, bool) {
	switch pt := v.(type) {
	case *MonthInterval:
		return *pt, true
	case MonthInterval:
		return pt, true
	case *arrow.MonthInterval:
		t := *pt
		return MonthInterval(t), true
	case arrow.MonthInterval:
		t := pt
		return MonthInterval(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) MonthInterval {
			if t {
				return MonthInterval(1)
			}
			return MonthInterval(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) MonthInterval {
			if t {
				return MonthInterval(1)
			}
			return MonthInterval(0)
		}(t), true
	case *Int32:
		t := *pt
		return MonthInterval(arrow.MonthInterval(int32(t))), true
	case Int32:
		t := pt
		return MonthInterval(arrow.MonthInterval(int32(t))), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewMonthInterval creates a new MonthInterval object
// from the given value provided as v.
func NewMonthInterval(v arrow.MonthInterval) MonthInterval {
	return MonthInterval(v)
}

// MonthInterval has logic to apply to this type.
type MonthInterval arrow.MonthInterval

// Value returns the underlying value in it's native type.
func (e MonthInterval) Value() arrow.MonthInterval {
	return arrow.MonthInterval(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e MonthInterval) compareTypes(r Object, f func(arrow.MonthInterval, arrow.MonthInterval) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case MonthInterval:
		return f(e.Value(), right.Value()), nil
	case *MonthInterval:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.MonthInterval", r, r)
	}
}

// Comparation methods

// Eq returns true if the left MonthInterval is equal to the right MonthInterval.
func (e MonthInterval) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.MonthInterval) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left MonthInterval
// is not equal to the right MonthInterval.
func (e MonthInterval) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left MonthInterval
// is less than the right MonthInterval.
func (e MonthInterval) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.MonthInterval) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left MonthInterval
// is less than or equal to the right MonthInterval.
func (e MonthInterval) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.MonthInterval) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left MonthInterval
// is greter than the right MonthInterval.
func (e MonthInterval) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.MonthInterval) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left MonthInterval
// is greter than or equal to the right MonthInterval.
func (e MonthInterval) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.MonthInterval) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the MonthInterval to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t MonthInterval) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the MonthInterval to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t MonthInterval) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToInt32Checked attempts to cast the MonthInterval to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t MonthInterval) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the MonthInterval to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t MonthInterval) ToInt32() Int32 {
	return Int32(t)
}

// ToMonthIntervalChecked attempts to cast the MonthInterval to a MonthInterval.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t MonthInterval) ToMonthIntervalChecked() (MonthInterval, Boolean) {
	return t.ToMonthInterval(), true
}

// ToMonthInterval attempts to cast the MonthInterval to a MonthInterval.
// The result is not checked for an overflow.
// Use the ToMonthIntervalChecked version of this method if you need to check for
// an overflow.
func (t MonthInterval) ToMonthInterval() MonthInterval {
	return t
}

// ToStringChecked attempts to cast the MonthInterval to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t MonthInterval) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the MonthInterval to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t MonthInterval) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

type CastableToString interface {
	ToStringChecked() (String, Boolean)
	ToString() String
}

// CastToString takes an interface{} type or any Object type and
// attempts to convert it to the String Object type.
func CastToString(v interface{}) (String, bool) {
	switch pt := v.(type) {
	case *String:
		return *pt, true
	case String:
		return pt, true
	case *string:
		t := *pt
		return String(t), true
	case string:
		t := pt
		return String(t), true
	case *Boolean:
		t := *pt
		return String(fmt.Sprintf("%t", t)), true
	case Boolean:
		t := pt
		return String(fmt.Sprintf("%t", t)), true
	case *Date32:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Date32:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Date64:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Date64:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *DayTimeInterval:
		t := *pt
		return String(fmt.Sprintf("%#v", t)), true
	case DayTimeInterval:
		t := pt
		return String(fmt.Sprintf("%#v", t)), true
	case *Decimal128:
		t := *pt
		return String(fmt.Sprintf("%#v", t)), true
	case Decimal128:
		t := pt
		return String(fmt.Sprintf("%#v", t)), true
	case *Duration:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Duration:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Float16:
		t := *pt
		return String(fmt.Sprintf("%#v", t)), true
	case Float16:
		t := pt
		return String(fmt.Sprintf("%#v", t)), true
	case *Float32:
		t := *pt
		return String(fmt.Sprintf("%g", t)), true
	case Float32:
		t := pt
		return String(fmt.Sprintf("%g", t)), true
	case *Float64:
		t := *pt
		return String(fmt.Sprintf("%g", t)), true
	case Float64:
		t := pt
		return String(fmt.Sprintf("%g", t)), true
	case *Int16:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Int16:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Int32:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Int32:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Int64:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Int64:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Int8:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Int8:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *MonthInterval:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case MonthInterval:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Time32:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Time32:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Time64:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Time64:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Timestamp:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Timestamp:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Uint16:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Uint16:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Uint32:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Uint32:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Uint64:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Uint64:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	case *Uint8:
		t := *pt
		return String(fmt.Sprintf("%d", t)), true
	case Uint8:
		t := pt
		return String(fmt.Sprintf("%d", t)), true
	default:
		// Also handles when v is nil
		return "", false
	}
}

// NewString creates a new String object
// from the given value provided as v.
func NewString(v string) String {
	return String(v)
}

// String has logic to apply to this type.
type String string

// Value returns the underlying value in it's native type.
func (e String) Value() string {
	return string(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e String) compareTypes(r Object, f func(string, string) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case String:
		return f(e.Value(), right.Value()), nil
	case *String:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.String", r, r)
	}
}

// Comparation methods

// Eq returns true if the left String is equal to the right String.
func (e String) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right string) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left String
// is not equal to the right String.
func (e String) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left String
// is less than the right String.
func (e String) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right string) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left String
// is less than or equal to the right String.
func (e String) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right string) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left String
// is greter than the right String.
func (e String) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right string) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left String
// is greter than or equal to the right String.
func (e String) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right string) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the String to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t String) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the String to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t String) ToBoolean() Boolean {
	return Boolean(t != "")
}

// ToStringChecked attempts to cast the String to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t String) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the String to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t String) ToString() String {
	return t
}

type CastableToTime32 interface {
	ToTime32Checked() (Time32, Boolean)
	ToTime32() Time32
}

// CastToTime32 takes an interface{} type or any Object type and
// attempts to convert it to the Time32 Object type.
func CastToTime32(v interface{}) (Time32, bool) {
	switch pt := v.(type) {
	case *Time32:
		return *pt, true
	case Time32:
		return pt, true
	case *arrow.Time32:
		t := *pt
		return Time32(t), true
	case arrow.Time32:
		t := pt
		return Time32(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Time32 {
			if t {
				return Time32(1)
			}
			return Time32(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Time32 {
			if t {
				return Time32(1)
			}
			return Time32(0)
		}(t), true
	case *Date64:
		t := *pt
		return Time32(t), true
	case Date64:
		t := pt
		return Time32(t), true
	case *Decimal128:
		t := *pt
		return Time32(t.toI64()), true
	case Decimal128:
		t := pt
		return Time32(t.toI64()), true
	case *Duration:
		t := *pt
		return Time32(t), true
	case Duration:
		t := pt
		return Time32(t), true
	case *Float16:
		t := *pt
		return Time32(t.tof32()), true
	case Float16:
		t := pt
		return Time32(t.tof32()), true
	case *Float32:
		t := *pt
		return Time32(t), true
	case Float32:
		t := pt
		return Time32(t), true
	case *Float64:
		t := *pt
		return Time32(t), true
	case Float64:
		t := pt
		return Time32(t), true
	case *Int16:
		t := *pt
		return Time32(t), true
	case Int16:
		t := pt
		return Time32(t), true
	case *Int32:
		t := *pt
		return Time32(t), true
	case Int32:
		t := pt
		return Time32(t), true
	case *Int64:
		t := *pt
		return Time32(t), true
	case Int64:
		t := pt
		return Time32(t), true
	case *Int8:
		t := *pt
		return Time32(t), true
	case Int8:
		t := pt
		return Time32(t), true
	case *Time64:
		t := *pt
		return Time32(t), true
	case Time64:
		t := pt
		return Time32(t), true
	case *Timestamp:
		t := *pt
		return Time32(t), true
	case Timestamp:
		t := pt
		return Time32(t), true
	case *Uint16:
		t := *pt
		return Time32(t), true
	case Uint16:
		t := pt
		return Time32(t), true
	case *Uint32:
		t := *pt
		return Time32(t), true
	case Uint32:
		t := pt
		return Time32(t), true
	case *Uint64:
		t := *pt
		return Time32(t), true
	case Uint64:
		t := pt
		return Time32(t), true
	case *Uint8:
		t := *pt
		return Time32(t), true
	case Uint8:
		t := pt
		return Time32(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewTime32 creates a new Time32 object
// from the given value provided as v.
func NewTime32(v arrow.Time32) Time32 {
	return Time32(v)
}

// Time32 has logic to apply to this type.
type Time32 arrow.Time32

// Value returns the underlying value in it's native type.
func (e Time32) Value() arrow.Time32 {
	return arrow.Time32(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Time32) compareTypes(r Object, f func(arrow.Time32, arrow.Time32) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Time32:
		return f(e.Value(), right.Value()), nil
	case *Time32:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Time32", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Time32 is equal to the right Time32.
func (e Time32) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time32) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Time32
// is not equal to the right Time32.
func (e Time32) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Time32
// is less than the right Time32.
func (e Time32) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time32) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Time32
// is less than or equal to the right Time32.
func (e Time32) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time32) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Time32
// is greter than the right Time32.
func (e Time32) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time32) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Time32
// is greter than or equal to the right Time32.
func (e Time32) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time32) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Time32 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Time32 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Time32) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Time32 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Time32 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Time32 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Time32 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Time32 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Time32 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Time32 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Time32 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Time32 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToTime32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Time32 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Time32 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Time32 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Time32 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Time32 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Time32 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToTime32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Time32 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Time32 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Time32 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Time32) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Time32 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Time32 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToTime32() Time32 {
	return t
}

// ToTime64Checked attempts to cast the Time32 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Time32 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Time32 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Time32 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Time32) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Time32 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToTime32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Time32 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Time32 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Time32 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Time32 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Time32 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Time32 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time32) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToTime32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Time32 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Time32) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToTime64 interface {
	ToTime64Checked() (Time64, Boolean)
	ToTime64() Time64
}

// CastToTime64 takes an interface{} type or any Object type and
// attempts to convert it to the Time64 Object type.
func CastToTime64(v interface{}) (Time64, bool) {
	switch pt := v.(type) {
	case *Time64:
		return *pt, true
	case Time64:
		return pt, true
	case *arrow.Time64:
		t := *pt
		return Time64(t), true
	case arrow.Time64:
		t := pt
		return Time64(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Time64 {
			if t {
				return Time64(1)
			}
			return Time64(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Time64 {
			if t {
				return Time64(1)
			}
			return Time64(0)
		}(t), true
	case *Date64:
		t := *pt
		return Time64(t), true
	case Date64:
		t := pt
		return Time64(t), true
	case *Decimal128:
		t := *pt
		return Time64(t.toI64()), true
	case Decimal128:
		t := pt
		return Time64(t.toI64()), true
	case *Duration:
		t := *pt
		return Time64(t), true
	case Duration:
		t := pt
		return Time64(t), true
	case *Float16:
		t := *pt
		return Time64(t.tof32()), true
	case Float16:
		t := pt
		return Time64(t.tof32()), true
	case *Float32:
		t := *pt
		return Time64(t), true
	case Float32:
		t := pt
		return Time64(t), true
	case *Float64:
		t := *pt
		return Time64(t), true
	case Float64:
		t := pt
		return Time64(t), true
	case *Int16:
		t := *pt
		return Time64(t), true
	case Int16:
		t := pt
		return Time64(t), true
	case *Int32:
		t := *pt
		return Time64(t), true
	case Int32:
		t := pt
		return Time64(t), true
	case *Int64:
		t := *pt
		return Time64(t), true
	case Int64:
		t := pt
		return Time64(t), true
	case *Int8:
		t := *pt
		return Time64(t), true
	case Int8:
		t := pt
		return Time64(t), true
	case *Time32:
		t := *pt
		return Time64(t), true
	case Time32:
		t := pt
		return Time64(t), true
	case *Timestamp:
		t := *pt
		return Time64(t), true
	case Timestamp:
		t := pt
		return Time64(t), true
	case *Uint16:
		t := *pt
		return Time64(t), true
	case Uint16:
		t := pt
		return Time64(t), true
	case *Uint32:
		t := *pt
		return Time64(t), true
	case Uint32:
		t := pt
		return Time64(t), true
	case *Uint64:
		t := *pt
		return Time64(t), true
	case Uint64:
		t := pt
		return Time64(t), true
	case *Uint8:
		t := *pt
		return Time64(t), true
	case Uint8:
		t := pt
		return Time64(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewTime64 creates a new Time64 object
// from the given value provided as v.
func NewTime64(v arrow.Time64) Time64 {
	return Time64(v)
}

// Time64 has logic to apply to this type.
type Time64 arrow.Time64

// Value returns the underlying value in it's native type.
func (e Time64) Value() arrow.Time64 {
	return arrow.Time64(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Time64) compareTypes(r Object, f func(arrow.Time64, arrow.Time64) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Time64:
		return f(e.Value(), right.Value()), nil
	case *Time64:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Time64", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Time64 is equal to the right Time64.
func (e Time64) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time64) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Time64
// is not equal to the right Time64.
func (e Time64) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Time64
// is less than the right Time64.
func (e Time64) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time64) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Time64
// is less than or equal to the right Time64.
func (e Time64) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time64) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Time64
// is greter than the right Time64.
func (e Time64) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time64) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Time64
// is greter than or equal to the right Time64.
func (e Time64) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Time64) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Time64 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Time64 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Time64) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Time64 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Time64 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Time64 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Time64 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Time64 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Time64 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Time64 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Time64 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Time64 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToTime64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Time64 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Time64 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToInt32Checked() (Int32, Boolean) {
	var converted Int32
	converted = Int32(t)
	v, err := converted.ToTime64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt32 attempts to cast the Time64 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Time64 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Time64 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Time64 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToTime64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Time64 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Time64 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Time64 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Time64) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Time64 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToTime32Checked() (Time32, Boolean) {
	var converted Time32
	converted = Time32(t)
	v, err := converted.ToTime64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime32 attempts to cast the Time64 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Time64 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Time64 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToTime64() Time64 {
	return t
}

// ToTimestampChecked attempts to cast the Time64 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Time64 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Time64) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Time64 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToTime64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Time64 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Time64 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToUint32Checked() (Uint32, Boolean) {
	var converted Uint32
	converted = Uint32(t)
	v, err := converted.ToTime64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint32 attempts to cast the Time64 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Time64 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Time64 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Time64 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Time64) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToTime64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Time64 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Time64) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToTimestamp interface {
	ToTimestampChecked() (Timestamp, Boolean)
	ToTimestamp() Timestamp
}

// CastToTimestamp takes an interface{} type or any Object type and
// attempts to convert it to the Timestamp Object type.
func CastToTimestamp(v interface{}) (Timestamp, bool) {
	switch pt := v.(type) {
	case *Timestamp:
		return *pt, true
	case Timestamp:
		return pt, true
	case *arrow.Timestamp:
		t := *pt
		return Timestamp(t), true
	case arrow.Timestamp:
		t := pt
		return Timestamp(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Timestamp {
			if t {
				return Timestamp(1)
			}
			return Timestamp(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Timestamp {
			if t {
				return Timestamp(1)
			}
			return Timestamp(0)
		}(t), true
	case *Date64:
		t := *pt
		return Timestamp(t), true
	case Date64:
		t := pt
		return Timestamp(t), true
	case *Decimal128:
		t := *pt
		return Timestamp(t.toI64()), true
	case Decimal128:
		t := pt
		return Timestamp(t.toI64()), true
	case *Duration:
		t := *pt
		return Timestamp(t), true
	case Duration:
		t := pt
		return Timestamp(t), true
	case *Float16:
		t := *pt
		return Timestamp(t.tof32()), true
	case Float16:
		t := pt
		return Timestamp(t.tof32()), true
	case *Float32:
		t := *pt
		return Timestamp(t), true
	case Float32:
		t := pt
		return Timestamp(t), true
	case *Float64:
		t := *pt
		return Timestamp(t), true
	case Float64:
		t := pt
		return Timestamp(t), true
	case *Int16:
		t := *pt
		return Timestamp(t), true
	case Int16:
		t := pt
		return Timestamp(t), true
	case *Int32:
		t := *pt
		return Timestamp(t), true
	case Int32:
		t := pt
		return Timestamp(t), true
	case *Int64:
		t := *pt
		return Timestamp(t), true
	case Int64:
		t := pt
		return Timestamp(t), true
	case *Int8:
		t := *pt
		return Timestamp(t), true
	case Int8:
		t := pt
		return Timestamp(t), true
	case *Time32:
		t := *pt
		return Timestamp(t), true
	case Time32:
		t := pt
		return Timestamp(t), true
	case *Time64:
		t := *pt
		return Timestamp(t), true
	case Time64:
		t := pt
		return Timestamp(t), true
	case *Uint16:
		t := *pt
		return Timestamp(t), true
	case Uint16:
		t := pt
		return Timestamp(t), true
	case *Uint32:
		t := *pt
		return Timestamp(t), true
	case Uint32:
		t := pt
		return Timestamp(t), true
	case *Uint64:
		t := *pt
		return Timestamp(t), true
	case Uint64:
		t := pt
		return Timestamp(t), true
	case *Uint8:
		t := *pt
		return Timestamp(t), true
	case Uint8:
		t := pt
		return Timestamp(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewTimestamp creates a new Timestamp object
// from the given value provided as v.
func NewTimestamp(v arrow.Timestamp) Timestamp {
	return Timestamp(v)
}

// Timestamp has logic to apply to this type.
type Timestamp arrow.Timestamp

// Value returns the underlying value in it's native type.
func (e Timestamp) Value() arrow.Timestamp {
	return arrow.Timestamp(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Timestamp) compareTypes(r Object, f func(arrow.Timestamp, arrow.Timestamp) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Timestamp:
		return f(e.Value(), right.Value()), nil
	case *Timestamp:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Timestamp", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Timestamp is equal to the right Timestamp.
func (e Timestamp) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Timestamp) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Timestamp
// is not equal to the right Timestamp.
func (e Timestamp) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Timestamp
// is less than the right Timestamp.
func (e Timestamp) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Timestamp) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Timestamp
// is less than or equal to the right Timestamp.
func (e Timestamp) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Timestamp) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Timestamp
// is greter than the right Timestamp.
func (e Timestamp) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Timestamp) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Timestamp
// is greter than or equal to the right Timestamp.
func (e Timestamp) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right arrow.Timestamp) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Timestamp to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Timestamp to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Timestamp to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Timestamp to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Timestamp to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Timestamp to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Timestamp to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Timestamp to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Timestamp to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Timestamp to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Timestamp to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToInt16Checked() (Int16, Boolean) {
	var converted Int16
	converted = Int16(t)
	v, err := converted.ToTimestamp().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt16 attempts to cast the Timestamp to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Timestamp to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToInt32Checked() (Int32, Boolean) {
	var converted Int32
	converted = Int32(t)
	v, err := converted.ToTimestamp().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt32 attempts to cast the Timestamp to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Timestamp to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Timestamp to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Timestamp to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToInt8Checked() (Int8, Boolean) {
	var converted Int8
	converted = Int8(t)
	v, err := converted.ToTimestamp().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToInt8 attempts to cast the Timestamp to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Timestamp to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Timestamp to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Timestamp to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToTime32Checked() (Time32, Boolean) {
	var converted Time32
	converted = Time32(t)
	v, err := converted.ToTimestamp().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToTime32 attempts to cast the Timestamp to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Timestamp to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Timestamp to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Timestamp to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Timestamp to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToTimestamp() Timestamp {
	return t
}

// ToUint16Checked attempts to cast the Timestamp to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToTimestamp().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Timestamp to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Timestamp to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToUint32Checked() (Uint32, Boolean) {
	var converted Uint32
	converted = Uint32(t)
	v, err := converted.ToTimestamp().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint32 attempts to cast the Timestamp to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Timestamp to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Timestamp to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Timestamp to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Timestamp) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToTimestamp().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Timestamp to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Timestamp) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToUint16 interface {
	ToUint16Checked() (Uint16, Boolean)
	ToUint16() Uint16
}

// CastToUint16 takes an interface{} type or any Object type and
// attempts to convert it to the Uint16 Object type.
func CastToUint16(v interface{}) (Uint16, bool) {
	switch pt := v.(type) {
	case *Uint16:
		return *pt, true
	case Uint16:
		return pt, true
	case *uint16:
		t := *pt
		return Uint16(t), true
	case uint16:
		t := pt
		return Uint16(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Uint16 {
			if t {
				return Uint16(1)
			}
			return Uint16(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Uint16 {
			if t {
				return Uint16(1)
			}
			return Uint16(0)
		}(t), true
	case *Date64:
		t := *pt
		return Uint16(t), true
	case Date64:
		t := pt
		return Uint16(t), true
	case *Decimal128:
		t := *pt
		return Uint16(t.toI64()), true
	case Decimal128:
		t := pt
		return Uint16(t.toI64()), true
	case *Duration:
		t := *pt
		return Uint16(t), true
	case Duration:
		t := pt
		return Uint16(t), true
	case *Float16:
		t := *pt
		return Uint16(t.tof32()), true
	case Float16:
		t := pt
		return Uint16(t.tof32()), true
	case *Float32:
		t := *pt
		return Uint16(t), true
	case Float32:
		t := pt
		return Uint16(t), true
	case *Float64:
		t := *pt
		return Uint16(t), true
	case Float64:
		t := pt
		return Uint16(t), true
	case *Int16:
		t := *pt
		return Uint16(t), true
	case Int16:
		t := pt
		return Uint16(t), true
	case *Int32:
		t := *pt
		return Uint16(t), true
	case Int32:
		t := pt
		return Uint16(t), true
	case *Int64:
		t := *pt
		return Uint16(t), true
	case Int64:
		t := pt
		return Uint16(t), true
	case *Int8:
		t := *pt
		return Uint16(t), true
	case Int8:
		t := pt
		return Uint16(t), true
	case *Time32:
		t := *pt
		return Uint16(t), true
	case Time32:
		t := pt
		return Uint16(t), true
	case *Time64:
		t := *pt
		return Uint16(t), true
	case Time64:
		t := pt
		return Uint16(t), true
	case *Timestamp:
		t := *pt
		return Uint16(t), true
	case Timestamp:
		t := pt
		return Uint16(t), true
	case *Uint32:
		t := *pt
		return Uint16(t), true
	case Uint32:
		t := pt
		return Uint16(t), true
	case *Uint64:
		t := *pt
		return Uint16(t), true
	case Uint64:
		t := pt
		return Uint16(t), true
	case *Uint8:
		t := *pt
		return Uint16(t), true
	case Uint8:
		t := pt
		return Uint16(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewUint16 creates a new Uint16 object
// from the given value provided as v.
func NewUint16(v uint16) Uint16 {
	return Uint16(v)
}

// Uint16 has logic to apply to this type.
type Uint16 uint16

// Value returns the underlying value in it's native type.
func (e Uint16) Value() uint16 {
	return uint16(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Uint16) compareTypes(r Object, f func(uint16, uint16) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Uint16:
		return f(e.Value(), right.Value()), nil
	case *Uint16:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Uint16", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Uint16 is equal to the right Uint16.
func (e Uint16) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint16) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Uint16
// is not equal to the right Uint16.
func (e Uint16) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Uint16
// is less than the right Uint16.
func (e Uint16) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint16) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Uint16
// is less than or equal to the right Uint16.
func (e Uint16) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint16) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Uint16
// is greter than the right Uint16.
func (e Uint16) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint16) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Uint16
// is greter than or equal to the right Uint16.
func (e Uint16) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint16) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Uint16 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Uint16 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Uint16) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Uint16 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Uint16 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Uint16 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Uint16 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Uint16 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Uint16 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Uint16 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Uint16 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Uint16 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Uint16 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Uint16 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Uint16 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Uint16 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Uint16 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Uint16 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Uint16 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Uint16 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Uint16 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Uint16) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Uint16 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Uint16 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Uint16 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Uint16 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Uint16 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Uint16 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Uint16) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Uint16 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Uint16 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToUint16() Uint16 {
	return t
}

// ToUint32Checked attempts to cast the Uint16 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Uint16 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Uint16 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Uint16 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Uint16 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint16) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToUint16().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Uint16 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Uint16) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToUint32 interface {
	ToUint32Checked() (Uint32, Boolean)
	ToUint32() Uint32
}

// CastToUint32 takes an interface{} type or any Object type and
// attempts to convert it to the Uint32 Object type.
func CastToUint32(v interface{}) (Uint32, bool) {
	switch pt := v.(type) {
	case *Uint32:
		return *pt, true
	case Uint32:
		return pt, true
	case *uint32:
		t := *pt
		return Uint32(t), true
	case uint32:
		t := pt
		return Uint32(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Uint32 {
			if t {
				return Uint32(1)
			}
			return Uint32(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Uint32 {
			if t {
				return Uint32(1)
			}
			return Uint32(0)
		}(t), true
	case *Date64:
		t := *pt
		return Uint32(t), true
	case Date64:
		t := pt
		return Uint32(t), true
	case *Decimal128:
		t := *pt
		return Uint32(t.toU64()), true
	case Decimal128:
		t := pt
		return Uint32(t.toU64()), true
	case *Duration:
		t := *pt
		return Uint32(t), true
	case Duration:
		t := pt
		return Uint32(t), true
	case *Float16:
		t := *pt
		return Uint32(t.tof32()), true
	case Float16:
		t := pt
		return Uint32(t.tof32()), true
	case *Float32:
		t := *pt
		return Uint32(t), true
	case Float32:
		t := pt
		return Uint32(t), true
	case *Float64:
		t := *pt
		return Uint32(t), true
	case Float64:
		t := pt
		return Uint32(t), true
	case *Int16:
		t := *pt
		return Uint32(t), true
	case Int16:
		t := pt
		return Uint32(t), true
	case *Int32:
		t := *pt
		return Uint32(t), true
	case Int32:
		t := pt
		return Uint32(t), true
	case *Int64:
		t := *pt
		return Uint32(t), true
	case Int64:
		t := pt
		return Uint32(t), true
	case *Int8:
		t := *pt
		return Uint32(t), true
	case Int8:
		t := pt
		return Uint32(t), true
	case *Time32:
		t := *pt
		return Uint32(t), true
	case Time32:
		t := pt
		return Uint32(t), true
	case *Time64:
		t := *pt
		return Uint32(t), true
	case Time64:
		t := pt
		return Uint32(t), true
	case *Timestamp:
		t := *pt
		return Uint32(t), true
	case Timestamp:
		t := pt
		return Uint32(t), true
	case *Uint16:
		t := *pt
		return Uint32(t), true
	case Uint16:
		t := pt
		return Uint32(t), true
	case *Uint64:
		t := *pt
		return Uint32(t), true
	case Uint64:
		t := pt
		return Uint32(t), true
	case *Uint8:
		t := *pt
		return Uint32(t), true
	case Uint8:
		t := pt
		return Uint32(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewUint32 creates a new Uint32 object
// from the given value provided as v.
func NewUint32(v uint32) Uint32 {
	return Uint32(v)
}

// Uint32 has logic to apply to this type.
type Uint32 uint32

// Value returns the underlying value in it's native type.
func (e Uint32) Value() uint32 {
	return uint32(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Uint32) compareTypes(r Object, f func(uint32, uint32) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Uint32:
		return f(e.Value(), right.Value()), nil
	case *Uint32:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Uint32", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Uint32 is equal to the right Uint32.
func (e Uint32) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint32) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Uint32
// is not equal to the right Uint32.
func (e Uint32) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Uint32
// is less than the right Uint32.
func (e Uint32) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint32) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Uint32
// is less than or equal to the right Uint32.
func (e Uint32) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint32) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Uint32
// is greter than the right Uint32.
func (e Uint32) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint32) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Uint32
// is greter than or equal to the right Uint32.
func (e Uint32) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint32) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Uint32 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Uint32 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Uint32) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Uint32 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Uint32 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Uint32 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Uint32 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Uint32 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Uint32 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Uint32 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Uint32 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Uint32 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Uint32 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Uint32 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Uint32 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Uint32 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Uint32 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Uint32 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Uint32 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Uint32 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Uint32 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Uint32) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Uint32 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Uint32 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Uint32 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Uint32 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Uint32 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Uint32 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Uint32) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Uint32 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToUint32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Uint32 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Uint32 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Uint32 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToUint32() Uint32 {
	return t
}

// ToUint64Checked attempts to cast the Uint32 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Uint32 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Uint32 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint32) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToUint32().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Uint32 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Uint32) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToUint64 interface {
	ToUint64Checked() (Uint64, Boolean)
	ToUint64() Uint64
}

// CastToUint64 takes an interface{} type or any Object type and
// attempts to convert it to the Uint64 Object type.
func CastToUint64(v interface{}) (Uint64, bool) {
	switch pt := v.(type) {
	case *Uint64:
		return *pt, true
	case Uint64:
		return pt, true
	case *uint64:
		t := *pt
		return Uint64(t), true
	case uint64:
		t := pt
		return Uint64(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Uint64 {
			if t {
				return Uint64(1)
			}
			return Uint64(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Uint64 {
			if t {
				return Uint64(1)
			}
			return Uint64(0)
		}(t), true
	case *Date32:
		t := *pt
		return Uint64(t), true
	case Date32:
		t := pt
		return Uint64(t), true
	case *Date64:
		t := *pt
		return Uint64(t), true
	case Date64:
		t := pt
		return Uint64(t), true
	case *Decimal128:
		t := *pt
		return Uint64(t.toU64()), true
	case Decimal128:
		t := pt
		return Uint64(t.toU64()), true
	case *Duration:
		t := *pt
		return Uint64(t), true
	case Duration:
		t := pt
		return Uint64(t), true
	case *Float16:
		t := *pt
		return Uint64(t.tof32()), true
	case Float16:
		t := pt
		return Uint64(t.tof32()), true
	case *Float32:
		t := *pt
		return Uint64(t), true
	case Float32:
		t := pt
		return Uint64(t), true
	case *Float64:
		t := *pt
		return Uint64(t), true
	case Float64:
		t := pt
		return Uint64(t), true
	case *Int16:
		t := *pt
		return Uint64(t), true
	case Int16:
		t := pt
		return Uint64(t), true
	case *Int32:
		t := *pt
		return Uint64(t), true
	case Int32:
		t := pt
		return Uint64(t), true
	case *Int64:
		t := *pt
		return Uint64(t), true
	case Int64:
		t := pt
		return Uint64(t), true
	case *Int8:
		t := *pt
		return Uint64(t), true
	case Int8:
		t := pt
		return Uint64(t), true
	case *Time32:
		t := *pt
		return Uint64(t), true
	case Time32:
		t := pt
		return Uint64(t), true
	case *Time64:
		t := *pt
		return Uint64(t), true
	case Time64:
		t := pt
		return Uint64(t), true
	case *Timestamp:
		t := *pt
		return Uint64(t), true
	case Timestamp:
		t := pt
		return Uint64(t), true
	case *Uint16:
		t := *pt
		return Uint64(t), true
	case Uint16:
		t := pt
		return Uint64(t), true
	case *Uint32:
		t := *pt
		return Uint64(t), true
	case Uint32:
		t := pt
		return Uint64(t), true
	case *Uint8:
		t := *pt
		return Uint64(t), true
	case Uint8:
		t := pt
		return Uint64(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewUint64 creates a new Uint64 object
// from the given value provided as v.
func NewUint64(v uint64) Uint64 {
	return Uint64(v)
}

// Uint64 has logic to apply to this type.
type Uint64 uint64

// Value returns the underlying value in it's native type.
func (e Uint64) Value() uint64 {
	return uint64(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Uint64) compareTypes(r Object, f func(uint64, uint64) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Uint64:
		return f(e.Value(), right.Value()), nil
	case *Uint64:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Uint64", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Uint64 is equal to the right Uint64.
func (e Uint64) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint64) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Uint64
// is not equal to the right Uint64.
func (e Uint64) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Uint64
// is less than the right Uint64.
func (e Uint64) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint64) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Uint64
// is less than or equal to the right Uint64.
func (e Uint64) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint64) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Uint64
// is greter than the right Uint64.
func (e Uint64) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint64) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Uint64
// is greter than or equal to the right Uint64.
func (e Uint64) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint64) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Uint64 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Uint64 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Uint64) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Uint64 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Uint64 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Uint64 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Uint64 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToDate64() Date64 {
	return Date64(t)
}

// ToDecimal128Checked attempts to cast the Uint64 to a Decimal128.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToDecimal128Checked() (Decimal128, Boolean) {
	return t.ToDecimal128(), true
}

// ToDecimal128 attempts to cast the Uint64 to a Decimal128.
// The result is not checked for an overflow.
// Use the ToDecimal128Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToDecimal128() Decimal128 {
	return Decimal128(decimal128.FromU64(uint64(t)))
}

// ToFloat32Checked attempts to cast the Uint64 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Uint64 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Uint64 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Uint64 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Uint64 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Uint64 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Uint64 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Uint64 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Uint64 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Uint64 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Uint64 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Uint64 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Uint64 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Uint64 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Uint64) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Uint64 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Uint64 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Uint64 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Uint64 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Uint64 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Uint64 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Uint64) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Uint64 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToUint16Checked() (Uint16, Boolean) {
	var converted Uint16
	converted = Uint16(t)
	v, err := converted.ToUint64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint16 attempts to cast the Uint64 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Uint64 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToUint32Checked() (Uint32, Boolean) {
	var converted Uint32
	converted = Uint32(t)
	v, err := converted.ToUint64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint32 attempts to cast the Uint64 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Uint64 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Uint64 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToUint64() Uint64 {
	return t
}

// ToUint8Checked attempts to cast the Uint64 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint64) ToUint8Checked() (Uint8, Boolean) {
	var converted Uint8
	converted = Uint8(t)
	v, err := converted.ToUint64().Eq(t)
	return converted, Boolean(err == nil && v)
}

// ToUint8 attempts to cast the Uint64 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Uint64) ToUint8() Uint8 {
	return Uint8(t)
}

type CastableToUint8 interface {
	ToUint8Checked() (Uint8, Boolean)
	ToUint8() Uint8
}

// CastToUint8 takes an interface{} type or any Object type and
// attempts to convert it to the Uint8 Object type.
func CastToUint8(v interface{}) (Uint8, bool) {
	switch pt := v.(type) {
	case *Uint8:
		return *pt, true
	case Uint8:
		return pt, true
	case *uint8:
		t := *pt
		return Uint8(t), true
	case uint8:
		t := pt
		return Uint8(t), true
	case *Boolean:
		t := *pt
		return func(t Boolean) Uint8 {
			if t {
				return Uint8(1)
			}
			return Uint8(0)
		}(t), true
	case Boolean:
		t := pt
		return func(t Boolean) Uint8 {
			if t {
				return Uint8(1)
			}
			return Uint8(0)
		}(t), true
	case *Date64:
		t := *pt
		return Uint8(t), true
	case Date64:
		t := pt
		return Uint8(t), true
	case *Decimal128:
		t := *pt
		return Uint8(t.toI64()), true
	case Decimal128:
		t := pt
		return Uint8(t.toI64()), true
	case *Duration:
		t := *pt
		return Uint8(t), true
	case Duration:
		t := pt
		return Uint8(t), true
	case *Float16:
		t := *pt
		return Uint8(t.tof32()), true
	case Float16:
		t := pt
		return Uint8(t.tof32()), true
	case *Float32:
		t := *pt
		return Uint8(t), true
	case Float32:
		t := pt
		return Uint8(t), true
	case *Float64:
		t := *pt
		return Uint8(t), true
	case Float64:
		t := pt
		return Uint8(t), true
	case *Int16:
		t := *pt
		return Uint8(t), true
	case Int16:
		t := pt
		return Uint8(t), true
	case *Int32:
		t := *pt
		return Uint8(t), true
	case Int32:
		t := pt
		return Uint8(t), true
	case *Int64:
		t := *pt
		return Uint8(t), true
	case Int64:
		t := pt
		return Uint8(t), true
	case *Int8:
		t := *pt
		return Uint8(t), true
	case Int8:
		t := pt
		return Uint8(t), true
	case *Time32:
		t := *pt
		return Uint8(t), true
	case Time32:
		t := pt
		return Uint8(t), true
	case *Time64:
		t := *pt
		return Uint8(t), true
	case Time64:
		t := pt
		return Uint8(t), true
	case *Timestamp:
		t := *pt
		return Uint8(t), true
	case Timestamp:
		t := pt
		return Uint8(t), true
	case *Uint16:
		t := *pt
		return Uint8(t), true
	case Uint16:
		t := pt
		return Uint8(t), true
	case *Uint32:
		t := *pt
		return Uint8(t), true
	case Uint32:
		t := pt
		return Uint8(t), true
	case *Uint64:
		t := *pt
		return Uint8(t), true
	case Uint64:
		t := pt
		return Uint8(t), true
	default:
		// Also handles when v is nil
		return 0, false
	}
}

// NewUint8 creates a new Uint8 object
// from the given value provided as v.
func NewUint8(v uint8) Uint8 {
	return Uint8(v)
}

// Uint8 has logic to apply to this type.
type Uint8 uint8

// Value returns the underlying value in it's native type.
func (e Uint8) Value() uint8 {
	return uint8(e)
}

// compare takes the left and right objects and applies the comparator function to them.
func (e Uint8) compareTypes(r Object, f func(uint8, uint8) Boolean) (Boolean, error) {
	if r == nil {
		return Boolean(false), nil
	}

	switch right := r.(type) {
	case Uint8:
		return f(e.Value(), right.Value()), nil
	case *Uint8:
		return f(e.Value(), right.Value()), nil
	default:
		return false, fmt.Errorf("cannot cast %T (%#v) to object.Uint8", r, r)
	}
}

// Comparation methods

// Eq returns true if the left Uint8 is equal to the right Uint8.
func (e Uint8) Eq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint8) Boolean {
		return Boolean(left == right)
	})
}

// Neq returns true if the left Uint8
// is not equal to the right Uint8.
func (e Uint8) Neq(r Object) (Boolean, error) {
	v, err := e.Eq(r)
	if err != nil {
		return Boolean(false), err
	}
	return !v, err
}

// Less returns true if the left Uint8
// is less than the right Uint8.
func (e Uint8) Less(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint8) Boolean {
		return Boolean(left < right)
	})
}

// LessEq returns true if the left Uint8
// is less than or equal to the right Uint8.
func (e Uint8) LessEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint8) Boolean {
		return Boolean(left <= right)
	})
}

// Greater returns true if the left Uint8
// is greter than the right Uint8.
func (e Uint8) Greater(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint8) Boolean {
		return Boolean(left > right)
	})
}

// GreaterEq returns true if the left Uint8
// is greter than or equal to the right Uint8.
func (e Uint8) GreaterEq(r Object) (Boolean, error) {
	return e.compareTypes(r, func(left, right uint8) Boolean {
		return Boolean(left >= right)
	})
}

// ToBooleanChecked attempts to cast the Uint8 to a Boolean.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToBooleanChecked() (Boolean, Boolean) {
	return t.ToBoolean(), true
}

// ToBoolean attempts to cast the Uint8 to a Boolean.
// The result is not checked for an overflow.
// Use the ToBooleanChecked version of this method if you need to check for
// an overflow.
func (t Uint8) ToBoolean() Boolean {
	return Boolean(t != 0)
}

// ToDate32Checked attempts to cast the Uint8 to a Date32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToDate32Checked() (Date32, Boolean) {
	return t.ToDate32(), true
}

// ToDate32 attempts to cast the Uint8 to a Date32.
// The result is not checked for an overflow.
// Use the ToDate32Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToDate32() Date32 {
	return Date32(t)
}

// ToDate64Checked attempts to cast the Uint8 to a Date64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToDate64Checked() (Date64, Boolean) {
	return t.ToDate64(), true
}

// ToDate64 attempts to cast the Uint8 to a Date64.
// The result is not checked for an overflow.
// Use the ToDate64Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToDate64() Date64 {
	return Date64(t)
}

// ToFloat32Checked attempts to cast the Uint8 to a Float32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToFloat32Checked() (Float32, Boolean) {
	return t.ToFloat32(), true
}

// ToFloat32 attempts to cast the Uint8 to a Float32.
// The result is not checked for an overflow.
// Use the ToFloat32Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToFloat32() Float32 {
	return Float32(t)
}

// ToFloat64Checked attempts to cast the Uint8 to a Float64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToFloat64Checked() (Float64, Boolean) {
	return t.ToFloat64(), true
}

// ToFloat64 attempts to cast the Uint8 to a Float64.
// The result is not checked for an overflow.
// Use the ToFloat64Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToFloat64() Float64 {
	return Float64(t)
}

// ToInt16Checked attempts to cast the Uint8 to a Int16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToInt16Checked() (Int16, Boolean) {
	return t.ToInt16(), true
}

// ToInt16 attempts to cast the Uint8 to a Int16.
// The result is not checked for an overflow.
// Use the ToInt16Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToInt16() Int16 {
	return Int16(t)
}

// ToInt32Checked attempts to cast the Uint8 to a Int32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToInt32Checked() (Int32, Boolean) {
	return t.ToInt32(), true
}

// ToInt32 attempts to cast the Uint8 to a Int32.
// The result is not checked for an overflow.
// Use the ToInt32Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToInt32() Int32 {
	return Int32(t)
}

// ToInt64Checked attempts to cast the Uint8 to a Int64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToInt64Checked() (Int64, Boolean) {
	return t.ToInt64(), true
}

// ToInt64 attempts to cast the Uint8 to a Int64.
// The result is not checked for an overflow.
// Use the ToInt64Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToInt64() Int64 {
	return Int64(t)
}

// ToInt8Checked attempts to cast the Uint8 to a Int8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToInt8Checked() (Int8, Boolean) {
	return t.ToInt8(), true
}

// ToInt8 attempts to cast the Uint8 to a Int8.
// The result is not checked for an overflow.
// Use the ToInt8Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToInt8() Int8 {
	return Int8(t)
}

// ToStringChecked attempts to cast the Uint8 to a String.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToStringChecked() (String, Boolean) {
	return t.ToString(), true
}

// ToString attempts to cast the Uint8 to a String.
// The result is not checked for an overflow.
// Use the ToStringChecked version of this method if you need to check for
// an overflow.
func (t Uint8) ToString() String {
	return String(fmt.Sprintf("%d", t))
}

// ToTime32Checked attempts to cast the Uint8 to a Time32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToTime32Checked() (Time32, Boolean) {
	return t.ToTime32(), true
}

// ToTime32 attempts to cast the Uint8 to a Time32.
// The result is not checked for an overflow.
// Use the ToTime32Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToTime32() Time32 {
	return Time32(t)
}

// ToTime64Checked attempts to cast the Uint8 to a Time64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToTime64Checked() (Time64, Boolean) {
	return t.ToTime64(), true
}

// ToTime64 attempts to cast the Uint8 to a Time64.
// The result is not checked for an overflow.
// Use the ToTime64Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToTime64() Time64 {
	return Time64(t)
}

// ToTimestampChecked attempts to cast the Uint8 to a Timestamp.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToTimestampChecked() (Timestamp, Boolean) {
	return t.ToTimestamp(), true
}

// ToTimestamp attempts to cast the Uint8 to a Timestamp.
// The result is not checked for an overflow.
// Use the ToTimestampChecked version of this method if you need to check for
// an overflow.
func (t Uint8) ToTimestamp() Timestamp {
	return Timestamp(t)
}

// ToUint16Checked attempts to cast the Uint8 to a Uint16.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToUint16Checked() (Uint16, Boolean) {
	return t.ToUint16(), true
}

// ToUint16 attempts to cast the Uint8 to a Uint16.
// The result is not checked for an overflow.
// Use the ToUint16Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToUint16() Uint16 {
	return Uint16(t)
}

// ToUint32Checked attempts to cast the Uint8 to a Uint32.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToUint32Checked() (Uint32, Boolean) {
	return t.ToUint32(), true
}

// ToUint32 attempts to cast the Uint8 to a Uint32.
// The result is not checked for an overflow.
// Use the ToUint32Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToUint32() Uint32 {
	return Uint32(t)
}

// ToUint64Checked attempts to cast the Uint8 to a Uint64.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToUint64Checked() (Uint64, Boolean) {
	return t.ToUint64(), true
}

// ToUint64 attempts to cast the Uint8 to a Uint64.
// The result is not checked for an overflow.
// Use the ToUint64Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToUint64() Uint64 {
	return Uint64(t)
}

// ToUint8Checked attempts to cast the Uint8 to a Uint8.
// The second return value will be false if there was an overflow or any other loss of precision.
// For example, going from Float64 to Int64 will result in anything after the decimal being truncated.
func (t Uint8) ToUint8Checked() (Uint8, Boolean) {
	return t.ToUint8(), true
}

// ToUint8 attempts to cast the Uint8 to a Uint8.
// The result is not checked for an overflow.
// Use the ToUint8Checked version of this method if you need to check for
// an overflow.
func (t Uint8) ToUint8() Uint8 {
	return t
}

var (
	_ Object = (*Boolean)(nil)
	_ Object = (*Date32)(nil)
	_ Object = (*Date64)(nil)
	_ Object = (*DayTimeInterval)(nil)
	_ Object = (*Decimal128)(nil)
	_ Object = (*Duration)(nil)
	_ Object = (*Float16)(nil)
	_ Object = (*Float32)(nil)
	_ Object = (*Float64)(nil)
	_ Object = (*Int16)(nil)
	_ Object = (*Int32)(nil)
	_ Object = (*Int64)(nil)
	_ Object = (*Int8)(nil)
	_ Object = (*MonthInterval)(nil)
	_ Object = (*String)(nil)
	_ Object = (*Time32)(nil)
	_ Object = (*Time64)(nil)
	_ Object = (*Timestamp)(nil)
	_ Object = (*Uint16)(nil)
	_ Object = (*Uint32)(nil)
	_ Object = (*Uint64)(nil)
	_ Object = (*Uint8)(nil)
)
