// Code generated by pkg/object/object.gen._test.go.tmpl. DO NOT EDIT.

// Copyright 2019 Nick Poorman
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package object

import (
	"errors"
	"fmt"
	"testing"

	"github.com/apache/arrow/go/v10/arrow"
	"github.com/apache/arrow/go/v10/arrow/decimal128"
	"github.com/apache/arrow/go/v10/arrow/float16"
)

func TestBooleanToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Boolean
		Want bool
	}{
		{false, false},
		{Boolean(true), true},
		{Boolean(true), true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestBooleanEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Boolean(false), Boolean(false), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestBooleanNeq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Boolean(false), Boolean(false), nil, false},
		{Boolean(false), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Boolean"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestBooleanLess(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Boolean(false), Boolean(false), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestBooleanLessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Boolean(false), Boolean(false), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestBooleanGreater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Boolean(false), Boolean(false), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestBooleanGreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Boolean(false), Boolean(false), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestBooleanCastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Boolean(false), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToBoolean(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Boolean
	}{
		{Boolean(false), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestBooleanCastableToDate32(t *testing.T) {
	cases := []struct {
		o    CastableToDate32
		want Date32
	}{
		{Boolean(false), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToDate32(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Date32
	}{
		{Boolean(false), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToDate32Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate32Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Date32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Date32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Boolean(false), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToDate64(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Date64
	}{
		{Boolean(false), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToDate64Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToDayTimeInterval(t *testing.T) {
	cases := []struct {
		o    CastableToDayTimeInterval
		want DayTimeInterval
	}{
		{Boolean(false), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))},
	}
	for _, c := range cases {
		value := c.o.ToDayTimeInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToDayTimeInterval(t *testing.T) {
	cases := []struct {
		o    Boolean
		want DayTimeInterval
	}{
		{Boolean(false), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))},
	}
	for _, c := range cases {
		value := c.o.ToDayTimeInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToDayTimeIntervalChecked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDayTimeIntervalChecked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to DayTimeInterval: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to DayTimeInterval - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToDecimal128(t *testing.T) {
	cases := []struct {
		o    CastableToDecimal128
		want Decimal128
	}{
		{Boolean(false), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToDecimal128(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Decimal128
	}{
		{Boolean(false), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToDecimal128Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDecimal128Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Decimal128: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Decimal128 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToDuration(t *testing.T) {
	cases := []struct {
		o    CastableToDuration
		want Duration
	}{
		{Boolean(false), Duration(0)},
	}
	for _, c := range cases {
		value := c.o.ToDuration()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToDuration(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Duration
	}{
		{Boolean(false), Duration(0)},
	}
	for _, c := range cases {
		value := c.o.ToDuration()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToDurationChecked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDurationChecked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Duration: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Duration - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToFloat16(t *testing.T) {
	cases := []struct {
		o    CastableToFloat16
		want Float16
	}{
		{Boolean(false), Float16(Float16(float16.New(0)))},
	}
	for _, c := range cases {
		value := c.o.ToFloat16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToFloat16(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Float16
	}{
		{Boolean(false), Float16(Float16(float16.New(0)))},
	}
	for _, c := range cases {
		value := c.o.ToFloat16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToFloat16Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat16Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Float16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Float16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Boolean(false), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToFloat32(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Float32
	}{
		{Boolean(false), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Boolean(false), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToFloat64(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Float64
	}{
		{Boolean(false), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Boolean(false), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToInt16(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Int16
	}{
		{Boolean(false), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToInt16Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Boolean(false), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToInt32(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Int32
	}{
		{Boolean(false), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToInt32Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Boolean(false), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToInt64(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Int64
	}{
		{Boolean(false), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToInt64Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Boolean(false), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToInt8(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Int8
	}{
		{Boolean(false), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToInt8Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToMonthInterval(t *testing.T) {
	cases := []struct {
		o    CastableToMonthInterval
		want MonthInterval
	}{
		{Boolean(false), MonthInterval(0)},
	}
	for _, c := range cases {
		value := c.o.ToMonthInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToMonthInterval(t *testing.T) {
	cases := []struct {
		o    Boolean
		want MonthInterval
	}{
		{Boolean(false), MonthInterval(0)},
	}
	for _, c := range cases {
		value := c.o.ToMonthInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToMonthIntervalChecked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToMonthIntervalChecked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to MonthInterval: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to MonthInterval - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToString(t *testing.T) {
	cases := []struct {
		o    CastableToString
		want String
	}{
		{Boolean(false), String("false")},
	}
	for _, c := range cases {
		value := c.o.ToString()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToString(t *testing.T) {
	cases := []struct {
		o    Boolean
		want String
	}{
		{Boolean(false), String("false")},
	}
	for _, c := range cases {
		value := c.o.ToString()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToStringChecked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToStringChecked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to String: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to String - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Boolean(false), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToTime32(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Time32
	}{
		{Boolean(false), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToTime32Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Boolean(false), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToTime64(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Time64
	}{
		{Boolean(false), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToTime64Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Boolean(false), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToTimestamp(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Timestamp
	}{
		{Boolean(false), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Boolean(false), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToUint16(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Uint16
	}{
		{Boolean(false), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToUint16Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Boolean(false), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToUint32(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Uint32
	}{
		{Boolean(false), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToUint32Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Boolean(false), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToUint64(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Uint64
	}{
		{Boolean(false), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToUint64Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestBooleanCastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Boolean(false), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodBooleanToUint8(t *testing.T) {
	cases := []struct {
		o    Boolean
		want Uint8
	}{
		{Boolean(false), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodBooleanToUint8Checked(t *testing.T) {
	cases := []struct {
		o Boolean
	}{
		{MaxBoolean},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToBooleanChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Boolean to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Boolean to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate32ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Date32
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate32Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date32(0), Date32(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate32Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date32(0), Date32(0), nil, false},
		{Date32(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Date32"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate32Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date32(0), Date32(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate32LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date32(0), Date32(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate32Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date32(0), Date32(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDate32GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date32(0), Date32(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDate32CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Date32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate32ToBoolean(t *testing.T) {
	cases := []struct {
		o    Date32
		want Boolean
	}{
		{Date32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate32ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Date32
	}{
		{MaxDate32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestDate32CastableToDate32(t *testing.T) {
	cases := []struct {
		o    CastableToDate32
		want Date32
	}{
		{Date32(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate32ToDate32(t *testing.T) {
	cases := []struct {
		o    Date32
		want Date32
	}{
		{Date32(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate32ToDate32Checked(t *testing.T) {
	cases := []struct {
		o Date32
	}{
		{MaxDate32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate32Checked()
		if ok {
			v, ok := converted.ToDate32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date32 to Date32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date32 to Date32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate32CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Date32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate32ToDate64(t *testing.T) {
	cases := []struct {
		o    Date32
		want Date64
	}{
		{Date32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate32ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Date32
	}{
		{MaxDate32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToDate32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date32 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date32 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate32CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Date32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate32ToInt32(t *testing.T) {
	cases := []struct {
		o    Date32
		want Int32
	}{
		{Date32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate32ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Date32
	}{
		{MaxDate32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToDate32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date32 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date32 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate32CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Date32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate32ToInt64(t *testing.T) {
	cases := []struct {
		o    Date32
		want Int64
	}{
		{Date32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate32ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Date32
	}{
		{MaxDate32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToDate32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date32 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date32 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate32CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Date32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate32ToUint64(t *testing.T) {
	cases := []struct {
		o    Date32
		want Uint64
	}{
		{Date32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate32ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Date32
	}{
		{MaxDate32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToDate32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date32 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date32 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Date64
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate64Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date64(0), Date64(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate64Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date64(0), Date64(0), nil, false},
		{Date64(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Date64"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate64Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date64(0), Date64(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate64LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date64(0), Date64(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDate64Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date64(0), Date64(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDate64GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Date64(0), Date64(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDate64CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Date64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToBoolean(t *testing.T) {
	cases := []struct {
		o    Date64
		want Boolean
	}{
		{Date64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestDate64CastableToDate32(t *testing.T) {
	cases := []struct {
		o    CastableToDate32
		want Date32
	}{
		{Date64(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToDate32(t *testing.T) {
	cases := []struct {
		o    Date64
		want Date32
	}{
		{Date64(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToDate32Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate32Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Date32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Date32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Date64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToDate64(t *testing.T) {
	cases := []struct {
		o    Date64
		want Date64
	}{
		{Date64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Date64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToFloat32(t *testing.T) {
	cases := []struct {
		o    Date64
		want Float32
	}{
		{Date64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Date64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToFloat64(t *testing.T) {
	cases := []struct {
		o    Date64
		want Float64
	}{
		{Date64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Date64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToInt16(t *testing.T) {
	cases := []struct {
		o    Date64
		want Int16
	}{
		{Date64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Date64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToInt32(t *testing.T) {
	cases := []struct {
		o    Date64
		want Int32
	}{
		{Date64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Date64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToInt64(t *testing.T) {
	cases := []struct {
		o    Date64
		want Int64
	}{
		{Date64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Date64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToInt8(t *testing.T) {
	cases := []struct {
		o    Date64
		want Int8
	}{
		{Date64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Date64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToTime32(t *testing.T) {
	cases := []struct {
		o    Date64
		want Time32
	}{
		{Date64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Date64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToTime64(t *testing.T) {
	cases := []struct {
		o    Date64
		want Time64
	}{
		{Date64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Date64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Date64
		want Timestamp
	}{
		{Date64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Date64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToUint16(t *testing.T) {
	cases := []struct {
		o    Date64
		want Uint16
	}{
		{Date64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Date64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToUint32(t *testing.T) {
	cases := []struct {
		o    Date64
		want Uint32
	}{
		{Date64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Date64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToUint64(t *testing.T) {
	cases := []struct {
		o    Date64
		want Uint64
	}{
		{Date64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDate64CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Date64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDate64ToUint8(t *testing.T) {
	cases := []struct {
		o    Date64
		want Uint8
	}{
		{Date64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDate64ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Date64
	}{
		{MaxDate64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToDate64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Date64 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Date64 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDayTimeIntervalToBoolean(t *testing.T) {
	cases := []struct {
		Obj  DayTimeInterval
		Want bool
	}{
		{DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}), false},
		{DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1}), true},
		{DayTimeInterval(arrow.DayTimeInterval{Days: 2, Milliseconds: 2}), true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDayTimeIntervalEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), nil, true},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1})
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 2, Milliseconds: 2})
			return &o
		}(), nil, false},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDayTimeIntervalNeq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), nil, false},
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.DayTimeInterval"), false},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), nil, false},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.DayTimeInterval"), false},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1})
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 2, Milliseconds: 2})
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1})
			return &o
		}(), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.DayTimeInterval"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDayTimeIntervalLess(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), nil, false},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), nil, false},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1})
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 2, Milliseconds: 2})
			return &o
		}(), nil, true},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDayTimeIntervalLessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), nil, true},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1})
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 2, Milliseconds: 2})
			return &o
		}(), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDayTimeIntervalGreater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), nil, false},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), nil, false},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1})
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 2, Milliseconds: 2})
			return &o
		}(), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDayTimeIntervalGreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), nil, true},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 1, Milliseconds: 1})
			return &o
		}(), func() Object {
			t.Helper()
			o := DayTimeInterval(arrow.DayTimeInterval{Days: 2, Milliseconds: 2})
			return &o
		}(), nil, false},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDayTimeIntervalCastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDayTimeIntervalToBoolean(t *testing.T) {
	cases := []struct {
		o    DayTimeInterval
		want Boolean
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDayTimeIntervalToBooleanChecked(t *testing.T) {
	cases := []struct {
		o DayTimeInterval
	}{
		{MaxDayTimeInterval},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestDayTimeIntervalCastableToDayTimeInterval(t *testing.T) {
	cases := []struct {
		o    CastableToDayTimeInterval
		want DayTimeInterval
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))},
	}
	for _, c := range cases {
		value := c.o.ToDayTimeInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDayTimeIntervalToDayTimeInterval(t *testing.T) {
	cases := []struct {
		o    DayTimeInterval
		want DayTimeInterval
	}{
		{DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0})), DayTimeInterval(DayTimeInterval(arrow.DayTimeInterval{Days: 0, Milliseconds: 0}))},
	}
	for _, c := range cases {
		value := c.o.ToDayTimeInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDayTimeIntervalToDayTimeIntervalChecked(t *testing.T) {
	cases := []struct {
		o DayTimeInterval
	}{
		{MaxDayTimeInterval},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDayTimeIntervalChecked()
		if ok {
			v, ok := converted.ToDayTimeIntervalChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for DayTimeInterval to DayTimeInterval: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for DayTimeInterval to DayTimeInterval - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDecimal128ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Decimal128
		Want bool
	}{
		{Decimal128(decimal128.New(0, 0)), false},
		{Decimal128(decimal128.New(1, 1)), true},
		{Decimal128(decimal128.New(2, 2)), true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDecimal128Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0))), nil, true},
		{func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(1, 1))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(2, 2))
			return &o
		}(), nil, false},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDecimal128Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0))), nil, false},
		{Decimal128(Decimal128(decimal128.New(0, 0))), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Decimal128"), false},
		{func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), nil, false},
		{func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Decimal128"), false},
		{func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(1, 1))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(2, 2))
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(1, 1))
			return &o
		}(), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Decimal128"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDecimal128Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0))), nil, false},
		{func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), nil, false},
		{func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(1, 1))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(2, 2))
			return &o
		}(), nil, true},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDecimal128LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0))), nil, true},
		{func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(1, 1))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(2, 2))
			return &o
		}(), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDecimal128Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0))), nil, false},
		{func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), nil, false},
		{func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(1, 1))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(2, 2))
			return &o
		}(), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDecimal128GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0))), nil, true},
		{func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(Decimal128(decimal128.New(0, 0)))
			return &o
		}(), nil, true},
		{func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(1, 1))
			return &o
		}(), func() Object {
			t.Helper()
			o := Decimal128(decimal128.New(2, 2))
			return &o
		}(), nil, false},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDecimal128CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDecimal128ToBoolean(t *testing.T) {
	cases := []struct {
		o    Decimal128
		want Boolean
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDecimal128ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Decimal128
	}{
		{MaxDecimal128},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestDecimal128CastableToDecimal128(t *testing.T) {
	cases := []struct {
		o    CastableToDecimal128
		want Decimal128
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDecimal128ToDecimal128(t *testing.T) {
	cases := []struct {
		o    Decimal128
		want Decimal128
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDecimal128ToDecimal128Checked(t *testing.T) {
	cases := []struct {
		o Decimal128
	}{
		{MaxDecimal128},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDecimal128Checked()
		if ok {
			v, ok := converted.ToDecimal128Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Decimal128 to Decimal128: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Decimal128 to Decimal128 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDecimal128CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDecimal128ToInt64(t *testing.T) {
	cases := []struct {
		o    Decimal128
		want Int64
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDecimal128ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Decimal128
	}{
		{MaxDecimal128},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToDecimal128Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Decimal128 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Decimal128 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDecimal128CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDecimal128ToUint64(t *testing.T) {
	cases := []struct {
		o    Decimal128
		want Uint64
	}{
		{Decimal128(Decimal128(decimal128.New(0, 0))), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDecimal128ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Decimal128
	}{
		{MaxDecimal128},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToDecimal128Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Decimal128 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Decimal128 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDurationToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Duration
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDurationEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Duration(0), Duration(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDurationNeq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Duration(0), Duration(0), nil, false},
		{Duration(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Duration"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDurationLess(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Duration(0), Duration(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDurationLessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Duration(0), Duration(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestDurationGreater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Duration(0), Duration(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDurationGreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Duration(0), Duration(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestDurationCastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Duration(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDurationToBoolean(t *testing.T) {
	cases := []struct {
		o    Duration
		want Boolean
	}{
		{Duration(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDurationToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Duration
	}{
		{MaxDuration},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestDurationCastableToDuration(t *testing.T) {
	cases := []struct {
		o    CastableToDuration
		want Duration
	}{
		{Duration(0), Duration(0)},
	}
	for _, c := range cases {
		value := c.o.ToDuration()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDurationToDuration(t *testing.T) {
	cases := []struct {
		o    Duration
		want Duration
	}{
		{Duration(0), Duration(0)},
	}
	for _, c := range cases {
		value := c.o.ToDuration()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDurationToDurationChecked(t *testing.T) {
	cases := []struct {
		o Duration
	}{
		{MaxDuration},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDurationChecked()
		if ok {
			v, ok := converted.ToDurationChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Duration to Duration: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Duration to Duration - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestDurationCastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Duration(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodDurationToInt64(t *testing.T) {
	cases := []struct {
		o    Duration
		want Int64
	}{
		{Duration(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodDurationToInt64Checked(t *testing.T) {
	cases := []struct {
		o Duration
	}{
		{MaxDuration},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToDurationChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Duration to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Duration to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat16ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Float16
		Want bool
	}{
		{Float16(float16.New(0)), false},
		{Float16(float16.New(1)), true},
		{Float16(float16.New(2)), true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat16Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0))), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat16Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0))), nil, false},
		{Float16(Float16(float16.New(0))), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Float16"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat16Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0))), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat16LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0))), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat16Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0))), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestFloat16GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0))), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestFloat16CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Float16(Float16(float16.New(0))), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat16ToBoolean(t *testing.T) {
	cases := []struct {
		o    Float16
		want Boolean
	}{
		{Float16(Float16(float16.New(0))), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat16ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Float16
	}{
		{MaxFloat16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestFloat16CastableToFloat16(t *testing.T) {
	cases := []struct {
		o    CastableToFloat16
		want Float16
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0)))},
	}
	for _, c := range cases {
		value := c.o.ToFloat16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat16ToFloat16(t *testing.T) {
	cases := []struct {
		o    Float16
		want Float16
	}{
		{Float16(Float16(float16.New(0))), Float16(Float16(float16.New(0)))},
	}
	for _, c := range cases {
		value := c.o.ToFloat16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat16ToFloat16Checked(t *testing.T) {
	cases := []struct {
		o Float16
	}{
		{MaxFloat16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat16Checked()
		if ok {
			v, ok := converted.ToFloat16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float16 to Float16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float16 to Float16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat16CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Float16(Float16(float16.New(0))), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat16ToFloat32(t *testing.T) {
	cases := []struct {
		o    Float16
		want Float32
	}{
		{Float16(Float16(float16.New(0))), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat16ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Float16
	}{
		{MaxFloat16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToFloat16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float16 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float16 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Float32
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat32Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float32(0), Float32(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat32Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float32(0), Float32(0), nil, false},
		{Float32(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Float32"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat32Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float32(0), Float32(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat32LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float32(0), Float32(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat32Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float32(0), Float32(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestFloat32GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float32(0), Float32(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestFloat32CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Float32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToBoolean(t *testing.T) {
	cases := []struct {
		o    Float32
		want Boolean
	}{
		{Float32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestFloat32CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Float32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToDate64(t *testing.T) {
	cases := []struct {
		o    Float32
		want Date64
	}{
		{Float32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToFloat16(t *testing.T) {
	cases := []struct {
		o    CastableToFloat16
		want Float16
	}{
		{Float32(0), Float16(Float16(float16.New(0)))},
	}
	for _, c := range cases {
		value := c.o.ToFloat16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToFloat16(t *testing.T) {
	cases := []struct {
		o    Float32
		want Float16
	}{
		{Float32(0), Float16(Float16(float16.New(0)))},
	}
	for _, c := range cases {
		value := c.o.ToFloat16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToFloat16Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat16Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Float16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Float16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Float32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToFloat32(t *testing.T) {
	cases := []struct {
		o    Float32
		want Float32
	}{
		{Float32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Float32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToFloat64(t *testing.T) {
	cases := []struct {
		o    Float32
		want Float64
	}{
		{Float32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Float32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToInt16(t *testing.T) {
	cases := []struct {
		o    Float32
		want Int16
	}{
		{Float32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Float32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToInt32(t *testing.T) {
	cases := []struct {
		o    Float32
		want Int32
	}{
		{Float32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Float32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToInt64(t *testing.T) {
	cases := []struct {
		o    Float32
		want Int64
	}{
		{Float32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Float32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToInt8(t *testing.T) {
	cases := []struct {
		o    Float32
		want Int8
	}{
		{Float32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Float32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToTime32(t *testing.T) {
	cases := []struct {
		o    Float32
		want Time32
	}{
		{Float32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Float32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToTime64(t *testing.T) {
	cases := []struct {
		o    Float32
		want Time64
	}{
		{Float32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Float32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Float32
		want Timestamp
	}{
		{Float32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Float32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToUint16(t *testing.T) {
	cases := []struct {
		o    Float32
		want Uint16
	}{
		{Float32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Float32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToUint32(t *testing.T) {
	cases := []struct {
		o    Float32
		want Uint32
	}{
		{Float32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Float32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToUint64(t *testing.T) {
	cases := []struct {
		o    Float32
		want Uint64
	}{
		{Float32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat32CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Float32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat32ToUint8(t *testing.T) {
	cases := []struct {
		o    Float32
		want Uint8
	}{
		{Float32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat32ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Float32
	}{
		{MaxFloat32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToFloat32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float32 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float32 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Float64
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat64Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float64(0), Float64(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat64Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float64(0), Float64(0), nil, false},
		{Float64(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Float64"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat64Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float64(0), Float64(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat64LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float64(0), Float64(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestFloat64Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float64(0), Float64(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestFloat64GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Float64(0), Float64(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestFloat64CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Float64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToBoolean(t *testing.T) {
	cases := []struct {
		o    Float64
		want Boolean
	}{
		{Float64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestFloat64CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Float64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToDate64(t *testing.T) {
	cases := []struct {
		o    Float64
		want Date64
	}{
		{Float64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Float64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToFloat32(t *testing.T) {
	cases := []struct {
		o    Float64
		want Float32
	}{
		{Float64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Float64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToFloat64(t *testing.T) {
	cases := []struct {
		o    Float64
		want Float64
	}{
		{Float64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Float64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToInt16(t *testing.T) {
	cases := []struct {
		o    Float64
		want Int16
	}{
		{Float64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Float64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToInt32(t *testing.T) {
	cases := []struct {
		o    Float64
		want Int32
	}{
		{Float64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Float64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToInt64(t *testing.T) {
	cases := []struct {
		o    Float64
		want Int64
	}{
		{Float64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Float64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToInt8(t *testing.T) {
	cases := []struct {
		o    Float64
		want Int8
	}{
		{Float64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Float64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToTime32(t *testing.T) {
	cases := []struct {
		o    Float64
		want Time32
	}{
		{Float64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Float64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToTime64(t *testing.T) {
	cases := []struct {
		o    Float64
		want Time64
	}{
		{Float64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Float64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Float64
		want Timestamp
	}{
		{Float64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Float64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToUint16(t *testing.T) {
	cases := []struct {
		o    Float64
		want Uint16
	}{
		{Float64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Float64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToUint32(t *testing.T) {
	cases := []struct {
		o    Float64
		want Uint32
	}{
		{Float64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Float64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToUint64(t *testing.T) {
	cases := []struct {
		o    Float64
		want Uint64
	}{
		{Float64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestFloat64CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Float64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodFloat64ToUint8(t *testing.T) {
	cases := []struct {
		o    Float64
		want Uint8
	}{
		{Float64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodFloat64ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Float64
	}{
		{MaxFloat64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToFloat64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Float64 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Float64 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Int16
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt16Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int16(0), Int16(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt16Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int16(0), Int16(0), nil, false},
		{Int16(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Int16"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt16Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int16(0), Int16(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt16LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int16(0), Int16(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt16Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int16(0), Int16(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt16GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int16(0), Int16(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt16CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Int16(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToBoolean(t *testing.T) {
	cases := []struct {
		o    Int16
		want Boolean
	}{
		{Int16(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestInt16CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Int16(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToDate64(t *testing.T) {
	cases := []struct {
		o    Int16
		want Date64
	}{
		{Int16(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Int16(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToFloat32(t *testing.T) {
	cases := []struct {
		o    Int16
		want Float32
	}{
		{Int16(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Int16(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToFloat64(t *testing.T) {
	cases := []struct {
		o    Int16
		want Float64
	}{
		{Int16(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Int16(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToInt16(t *testing.T) {
	cases := []struct {
		o    Int16
		want Int16
	}{
		{Int16(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Int16(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToInt32(t *testing.T) {
	cases := []struct {
		o    Int16
		want Int32
	}{
		{Int16(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Int16(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToInt64(t *testing.T) {
	cases := []struct {
		o    Int16
		want Int64
	}{
		{Int16(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Int16(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToInt8(t *testing.T) {
	cases := []struct {
		o    Int16
		want Int8
	}{
		{Int16(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Int16(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToTime32(t *testing.T) {
	cases := []struct {
		o    Int16
		want Time32
	}{
		{Int16(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Int16(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToTime64(t *testing.T) {
	cases := []struct {
		o    Int16
		want Time64
	}{
		{Int16(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Int16(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Int16
		want Timestamp
	}{
		{Int16(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Int16(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToUint16(t *testing.T) {
	cases := []struct {
		o    Int16
		want Uint16
	}{
		{Int16(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Int16(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToUint32(t *testing.T) {
	cases := []struct {
		o    Int16
		want Uint32
	}{
		{Int16(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Int16(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToUint64(t *testing.T) {
	cases := []struct {
		o    Int16
		want Uint64
	}{
		{Int16(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt16CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Int16(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt16ToUint8(t *testing.T) {
	cases := []struct {
		o    Int16
		want Uint8
	}{
		{Int16(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt16ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Int16
	}{
		{MaxInt16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToInt16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int16 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int16 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Int32
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt32Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int32(0), Int32(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt32Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int32(0), Int32(0), nil, false},
		{Int32(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Int32"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt32Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int32(0), Int32(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt32LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int32(0), Int32(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt32Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int32(0), Int32(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt32GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int32(0), Int32(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt32CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Int32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToBoolean(t *testing.T) {
	cases := []struct {
		o    Int32
		want Boolean
	}{
		{Int32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestInt32CastableToDate32(t *testing.T) {
	cases := []struct {
		o    CastableToDate32
		want Date32
	}{
		{Int32(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToDate32(t *testing.T) {
	cases := []struct {
		o    Int32
		want Date32
	}{
		{Int32(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToDate32Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate32Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Date32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Date32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Int32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToDate64(t *testing.T) {
	cases := []struct {
		o    Int32
		want Date64
	}{
		{Int32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Int32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToFloat32(t *testing.T) {
	cases := []struct {
		o    Int32
		want Float32
	}{
		{Int32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Int32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToFloat64(t *testing.T) {
	cases := []struct {
		o    Int32
		want Float64
	}{
		{Int32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Int32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToInt16(t *testing.T) {
	cases := []struct {
		o    Int32
		want Int16
	}{
		{Int32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Int32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToInt32(t *testing.T) {
	cases := []struct {
		o    Int32
		want Int32
	}{
		{Int32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Int32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToInt64(t *testing.T) {
	cases := []struct {
		o    Int32
		want Int64
	}{
		{Int32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Int32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToInt8(t *testing.T) {
	cases := []struct {
		o    Int32
		want Int8
	}{
		{Int32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToMonthInterval(t *testing.T) {
	cases := []struct {
		o    CastableToMonthInterval
		want MonthInterval
	}{
		{Int32(0), MonthInterval(0)},
	}
	for _, c := range cases {
		value := c.o.ToMonthInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToMonthInterval(t *testing.T) {
	cases := []struct {
		o    Int32
		want MonthInterval
	}{
		{Int32(0), MonthInterval(0)},
	}
	for _, c := range cases {
		value := c.o.ToMonthInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToMonthIntervalChecked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToMonthIntervalChecked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to MonthInterval: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to MonthInterval - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Int32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToTime32(t *testing.T) {
	cases := []struct {
		o    Int32
		want Time32
	}{
		{Int32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Int32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToTime64(t *testing.T) {
	cases := []struct {
		o    Int32
		want Time64
	}{
		{Int32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Int32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Int32
		want Timestamp
	}{
		{Int32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Int32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToUint16(t *testing.T) {
	cases := []struct {
		o    Int32
		want Uint16
	}{
		{Int32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Int32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToUint32(t *testing.T) {
	cases := []struct {
		o    Int32
		want Uint32
	}{
		{Int32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Int32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToUint64(t *testing.T) {
	cases := []struct {
		o    Int32
		want Uint64
	}{
		{Int32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt32CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Int32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt32ToUint8(t *testing.T) {
	cases := []struct {
		o    Int32
		want Uint8
	}{
		{Int32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt32ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Int32
	}{
		{MaxInt32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToInt32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int32 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int32 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Int64
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt64Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int64(0), Int64(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt64Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int64(0), Int64(0), nil, false},
		{Int64(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Int64"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt64Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int64(0), Int64(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt64LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int64(0), Int64(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt64Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int64(0), Int64(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt64GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int64(0), Int64(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt64CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Int64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToBoolean(t *testing.T) {
	cases := []struct {
		o    Int64
		want Boolean
	}{
		{Int64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestInt64CastableToDate32(t *testing.T) {
	cases := []struct {
		o    CastableToDate32
		want Date32
	}{
		{Int64(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToDate32(t *testing.T) {
	cases := []struct {
		o    Int64
		want Date32
	}{
		{Int64(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToDate32Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate32Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Date32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Date32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Int64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToDate64(t *testing.T) {
	cases := []struct {
		o    Int64
		want Date64
	}{
		{Int64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToDecimal128(t *testing.T) {
	cases := []struct {
		o    CastableToDecimal128
		want Decimal128
	}{
		{Int64(0), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToDecimal128(t *testing.T) {
	cases := []struct {
		o    Int64
		want Decimal128
	}{
		{Int64(0), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToDecimal128Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDecimal128Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Decimal128: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Decimal128 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToDuration(t *testing.T) {
	cases := []struct {
		o    CastableToDuration
		want Duration
	}{
		{Int64(0), Duration(0)},
	}
	for _, c := range cases {
		value := c.o.ToDuration()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToDuration(t *testing.T) {
	cases := []struct {
		o    Int64
		want Duration
	}{
		{Int64(0), Duration(0)},
	}
	for _, c := range cases {
		value := c.o.ToDuration()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToDurationChecked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDurationChecked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Duration: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Duration - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Int64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToFloat32(t *testing.T) {
	cases := []struct {
		o    Int64
		want Float32
	}{
		{Int64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Int64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToFloat64(t *testing.T) {
	cases := []struct {
		o    Int64
		want Float64
	}{
		{Int64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Int64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToInt16(t *testing.T) {
	cases := []struct {
		o    Int64
		want Int16
	}{
		{Int64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Int64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToInt32(t *testing.T) {
	cases := []struct {
		o    Int64
		want Int32
	}{
		{Int64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Int64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToInt64(t *testing.T) {
	cases := []struct {
		o    Int64
		want Int64
	}{
		{Int64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Int64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToInt8(t *testing.T) {
	cases := []struct {
		o    Int64
		want Int8
	}{
		{Int64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Int64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToTime32(t *testing.T) {
	cases := []struct {
		o    Int64
		want Time32
	}{
		{Int64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Int64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToTime64(t *testing.T) {
	cases := []struct {
		o    Int64
		want Time64
	}{
		{Int64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Int64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Int64
		want Timestamp
	}{
		{Int64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Int64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToUint16(t *testing.T) {
	cases := []struct {
		o    Int64
		want Uint16
	}{
		{Int64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Int64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToUint32(t *testing.T) {
	cases := []struct {
		o    Int64
		want Uint32
	}{
		{Int64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Int64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToUint64(t *testing.T) {
	cases := []struct {
		o    Int64
		want Uint64
	}{
		{Int64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt64CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Int64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt64ToUint8(t *testing.T) {
	cases := []struct {
		o    Int64
		want Uint8
	}{
		{Int64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt64ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Int64
	}{
		{MaxInt64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToInt64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int64 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int64 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Int8
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt8Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int8(0), Int8(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt8Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int8(0), Int8(0), nil, false},
		{Int8(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Int8"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt8Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int8(0), Int8(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt8LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int8(0), Int8(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestInt8Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int8(0), Int8(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt8GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Int8(0), Int8(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestInt8CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Int8(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToBoolean(t *testing.T) {
	cases := []struct {
		o    Int8
		want Boolean
	}{
		{Int8(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestInt8CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Int8(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToDate64(t *testing.T) {
	cases := []struct {
		o    Int8
		want Date64
	}{
		{Int8(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Int8(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToFloat32(t *testing.T) {
	cases := []struct {
		o    Int8
		want Float32
	}{
		{Int8(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Int8(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToFloat64(t *testing.T) {
	cases := []struct {
		o    Int8
		want Float64
	}{
		{Int8(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Int8(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToInt16(t *testing.T) {
	cases := []struct {
		o    Int8
		want Int16
	}{
		{Int8(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Int8(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToInt32(t *testing.T) {
	cases := []struct {
		o    Int8
		want Int32
	}{
		{Int8(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Int8(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToInt64(t *testing.T) {
	cases := []struct {
		o    Int8
		want Int64
	}{
		{Int8(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Int8(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToInt8(t *testing.T) {
	cases := []struct {
		o    Int8
		want Int8
	}{
		{Int8(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Int8(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToTime32(t *testing.T) {
	cases := []struct {
		o    Int8
		want Time32
	}{
		{Int8(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Int8(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToTime64(t *testing.T) {
	cases := []struct {
		o    Int8
		want Time64
	}{
		{Int8(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Int8(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Int8
		want Timestamp
	}{
		{Int8(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Int8(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToUint16(t *testing.T) {
	cases := []struct {
		o    Int8
		want Uint16
	}{
		{Int8(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Int8(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToUint32(t *testing.T) {
	cases := []struct {
		o    Int8
		want Uint32
	}{
		{Int8(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Int8(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToUint64(t *testing.T) {
	cases := []struct {
		o    Int8
		want Uint64
	}{
		{Int8(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestInt8CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Int8(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodInt8ToUint8(t *testing.T) {
	cases := []struct {
		o    Int8
		want Uint8
	}{
		{Int8(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodInt8ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Int8
	}{
		{MaxInt8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToInt8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Int8 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Int8 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestMonthIntervalToBoolean(t *testing.T) {
	cases := []struct {
		Obj  MonthInterval
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMonthIntervalEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{MonthInterval(0), MonthInterval(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMonthIntervalNeq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{MonthInterval(0), MonthInterval(0), nil, false},
		{MonthInterval(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.MonthInterval"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMonthIntervalLess(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{MonthInterval(0), MonthInterval(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMonthIntervalLessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{MonthInterval(0), MonthInterval(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMonthIntervalGreater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{MonthInterval(0), MonthInterval(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestMonthIntervalGreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{MonthInterval(0), MonthInterval(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestMonthIntervalCastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{MonthInterval(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodMonthIntervalToBoolean(t *testing.T) {
	cases := []struct {
		o    MonthInterval
		want Boolean
	}{
		{MonthInterval(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodMonthIntervalToBooleanChecked(t *testing.T) {
	cases := []struct {
		o MonthInterval
	}{
		{MaxMonthInterval},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestMonthIntervalCastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{MonthInterval(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodMonthIntervalToInt32(t *testing.T) {
	cases := []struct {
		o    MonthInterval
		want Int32
	}{
		{MonthInterval(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodMonthIntervalToInt32Checked(t *testing.T) {
	cases := []struct {
		o MonthInterval
	}{
		{MaxMonthInterval},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToMonthIntervalChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for MonthInterval to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for MonthInterval to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestMonthIntervalCastableToMonthInterval(t *testing.T) {
	cases := []struct {
		o    CastableToMonthInterval
		want MonthInterval
	}{
		{MonthInterval(0), MonthInterval(0)},
	}
	for _, c := range cases {
		value := c.o.ToMonthInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodMonthIntervalToMonthInterval(t *testing.T) {
	cases := []struct {
		o    MonthInterval
		want MonthInterval
	}{
		{MonthInterval(0), MonthInterval(0)},
	}
	for _, c := range cases {
		value := c.o.ToMonthInterval()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodMonthIntervalToMonthIntervalChecked(t *testing.T) {
	cases := []struct {
		o MonthInterval
	}{
		{MaxMonthInterval},
	}
	for _, c := range cases {
		converted, ok := c.o.ToMonthIntervalChecked()
		if ok {
			v, ok := converted.ToMonthIntervalChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for MonthInterval to MonthInterval: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for MonthInterval to MonthInterval - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestStringToBoolean(t *testing.T) {
	cases := []struct {
		Obj  String
		Want bool
	}{
		{"", false},
		{String("%v"), true},
		{String("%v"), true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestStringEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{String(""), String(""), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestStringNeq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{String(""), String(""), nil, false},
		{String(""), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.String"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestStringLess(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{String(""), String(""), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestStringLessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{String(""), String(""), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestStringGreater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{String(""), String(""), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestStringGreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{String(""), String(""), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestStringCastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{String(""), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodStringToBoolean(t *testing.T) {
	cases := []struct {
		o    String
		want Boolean
	}{
		{String(""), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodStringToBooleanChecked(t *testing.T) {
	cases := []struct {
		o String
	}{
		{String("abc")},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestStringCastableToString(t *testing.T) {
	cases := []struct {
		o    CastableToString
		want String
	}{
		{String(""), String("")},
	}
	for _, c := range cases {
		value := c.o.ToString()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodStringToString(t *testing.T) {
	cases := []struct {
		o    String
		want String
	}{
		{String(""), String("")},
	}
	for _, c := range cases {
		value := c.o.ToString()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodStringToStringChecked(t *testing.T) {
	cases := []struct {
		o String
	}{
		{String("abc")},
	}
	for _, c := range cases {
		converted, ok := c.o.ToStringChecked()
		if ok {
			v, ok := converted.ToStringChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for String to String: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for String to String - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Time32
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime32Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time32(0), Time32(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime32Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time32(0), Time32(0), nil, false},
		{Time32(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Time32"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime32Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time32(0), Time32(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime32LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time32(0), Time32(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime32Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time32(0), Time32(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestTime32GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time32(0), Time32(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestTime32CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Time32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToBoolean(t *testing.T) {
	cases := []struct {
		o    Time32
		want Boolean
	}{
		{Time32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestTime32CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Time32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToDate64(t *testing.T) {
	cases := []struct {
		o    Time32
		want Date64
	}{
		{Time32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Time32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToFloat32(t *testing.T) {
	cases := []struct {
		o    Time32
		want Float32
	}{
		{Time32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Time32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToFloat64(t *testing.T) {
	cases := []struct {
		o    Time32
		want Float64
	}{
		{Time32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Time32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToInt16(t *testing.T) {
	cases := []struct {
		o    Time32
		want Int16
	}{
		{Time32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Time32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToInt32(t *testing.T) {
	cases := []struct {
		o    Time32
		want Int32
	}{
		{Time32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Time32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToInt64(t *testing.T) {
	cases := []struct {
		o    Time32
		want Int64
	}{
		{Time32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Time32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToInt8(t *testing.T) {
	cases := []struct {
		o    Time32
		want Int8
	}{
		{Time32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Time32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToTime32(t *testing.T) {
	cases := []struct {
		o    Time32
		want Time32
	}{
		{Time32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Time32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToTime64(t *testing.T) {
	cases := []struct {
		o    Time32
		want Time64
	}{
		{Time32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Time32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Time32
		want Timestamp
	}{
		{Time32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Time32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToUint16(t *testing.T) {
	cases := []struct {
		o    Time32
		want Uint16
	}{
		{Time32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Time32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToUint32(t *testing.T) {
	cases := []struct {
		o    Time32
		want Uint32
	}{
		{Time32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Time32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToUint64(t *testing.T) {
	cases := []struct {
		o    Time32
		want Uint64
	}{
		{Time32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime32CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Time32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime32ToUint8(t *testing.T) {
	cases := []struct {
		o    Time32
		want Uint8
	}{
		{Time32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime32ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Time32
	}{
		{MaxTime32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToTime32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time32 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time32 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Time64
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime64Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time64(0), Time64(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime64Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time64(0), Time64(0), nil, false},
		{Time64(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Time64"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime64Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time64(0), Time64(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime64LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time64(0), Time64(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTime64Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time64(0), Time64(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestTime64GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Time64(0), Time64(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestTime64CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Time64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToBoolean(t *testing.T) {
	cases := []struct {
		o    Time64
		want Boolean
	}{
		{Time64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestTime64CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Time64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToDate64(t *testing.T) {
	cases := []struct {
		o    Time64
		want Date64
	}{
		{Time64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Time64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToFloat32(t *testing.T) {
	cases := []struct {
		o    Time64
		want Float32
	}{
		{Time64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Time64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToFloat64(t *testing.T) {
	cases := []struct {
		o    Time64
		want Float64
	}{
		{Time64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Time64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToInt16(t *testing.T) {
	cases := []struct {
		o    Time64
		want Int16
	}{
		{Time64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Time64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToInt32(t *testing.T) {
	cases := []struct {
		o    Time64
		want Int32
	}{
		{Time64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Time64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToInt64(t *testing.T) {
	cases := []struct {
		o    Time64
		want Int64
	}{
		{Time64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Time64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToInt8(t *testing.T) {
	cases := []struct {
		o    Time64
		want Int8
	}{
		{Time64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Time64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToTime32(t *testing.T) {
	cases := []struct {
		o    Time64
		want Time32
	}{
		{Time64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Time64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToTime64(t *testing.T) {
	cases := []struct {
		o    Time64
		want Time64
	}{
		{Time64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Time64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Time64
		want Timestamp
	}{
		{Time64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Time64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToUint16(t *testing.T) {
	cases := []struct {
		o    Time64
		want Uint16
	}{
		{Time64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Time64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToUint32(t *testing.T) {
	cases := []struct {
		o    Time64
		want Uint32
	}{
		{Time64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Time64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToUint64(t *testing.T) {
	cases := []struct {
		o    Time64
		want Uint64
	}{
		{Time64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTime64CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Time64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTime64ToUint8(t *testing.T) {
	cases := []struct {
		o    Time64
		want Uint8
	}{
		{Time64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTime64ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Time64
	}{
		{MaxTime64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToTime64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Time64 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Time64 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Timestamp
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTimestampEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Timestamp(0), Timestamp(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTimestampNeq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Timestamp(0), Timestamp(0), nil, false},
		{Timestamp(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Timestamp"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTimestampLess(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Timestamp(0), Timestamp(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTimestampLessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Timestamp(0), Timestamp(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestTimestampGreater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Timestamp(0), Timestamp(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestTimestampGreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Timestamp(0), Timestamp(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestTimestampCastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Timestamp(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToBoolean(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Boolean
	}{
		{Timestamp(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestTimestampCastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Timestamp(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToDate64(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Date64
	}{
		{Timestamp(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToDate64Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Timestamp(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToFloat32(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Float32
	}{
		{Timestamp(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Timestamp(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToFloat64(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Float64
	}{
		{Timestamp(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Timestamp(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToInt16(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Int16
	}{
		{Timestamp(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToInt16Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Timestamp(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToInt32(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Int32
	}{
		{Timestamp(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToInt32Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Timestamp(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToInt64(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Int64
	}{
		{Timestamp(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToInt64Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Timestamp(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToInt8(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Int8
	}{
		{Timestamp(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToInt8Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Timestamp(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToTime32(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Time32
	}{
		{Timestamp(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToTime32Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Timestamp(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToTime64(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Time64
	}{
		{Timestamp(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToTime64Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Timestamp(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToTimestamp(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Timestamp
	}{
		{Timestamp(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Timestamp(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToUint16(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Uint16
	}{
		{Timestamp(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToUint16Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Timestamp(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToUint32(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Uint32
	}{
		{Timestamp(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToUint32Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Timestamp(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToUint64(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Uint64
	}{
		{Timestamp(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToUint64Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestTimestampCastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Timestamp(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodTimestampToUint8(t *testing.T) {
	cases := []struct {
		o    Timestamp
		want Uint8
	}{
		{Timestamp(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodTimestampToUint8Checked(t *testing.T) {
	cases := []struct {
		o Timestamp
	}{
		{MaxTimestamp},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToTimestampChecked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Timestamp to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Timestamp to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Uint16
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint16Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint16(0), Uint16(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint16Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint16(0), Uint16(0), nil, false},
		{Uint16(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Uint16"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint16Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint16(0), Uint16(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint16LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint16(0), Uint16(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint16Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint16(0), Uint16(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint16GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint16(0), Uint16(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint16CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Uint16(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToBoolean(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Boolean
	}{
		{Uint16(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestUint16CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Uint16(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToDate64(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Date64
	}{
		{Uint16(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Uint16(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToFloat32(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Float32
	}{
		{Uint16(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Uint16(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToFloat64(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Float64
	}{
		{Uint16(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Uint16(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToInt16(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Int16
	}{
		{Uint16(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Uint16(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToInt32(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Int32
	}{
		{Uint16(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Uint16(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToInt64(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Int64
	}{
		{Uint16(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Uint16(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToInt8(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Int8
	}{
		{Uint16(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Uint16(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToTime32(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Time32
	}{
		{Uint16(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Uint16(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToTime64(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Time64
	}{
		{Uint16(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Uint16(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Timestamp
	}{
		{Uint16(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Uint16(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToUint16(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Uint16
	}{
		{Uint16(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Uint16(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToUint32(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Uint32
	}{
		{Uint16(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Uint16(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToUint64(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Uint64
	}{
		{Uint16(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint16CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Uint16(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint16ToUint8(t *testing.T) {
	cases := []struct {
		o    Uint16
		want Uint8
	}{
		{Uint16(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint16ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Uint16
	}{
		{MaxUint16},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToUint16Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint16 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint16 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Uint32
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint32Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint32(0), Uint32(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint32Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint32(0), Uint32(0), nil, false},
		{Uint32(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Uint32"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint32Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint32(0), Uint32(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint32LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint32(0), Uint32(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint32Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint32(0), Uint32(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint32GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint32(0), Uint32(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint32CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Uint32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToBoolean(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Boolean
	}{
		{Uint32(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestUint32CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Uint32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToDate64(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Date64
	}{
		{Uint32(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Uint32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToFloat32(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Float32
	}{
		{Uint32(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Uint32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToFloat64(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Float64
	}{
		{Uint32(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Uint32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToInt16(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Int16
	}{
		{Uint32(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Uint32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToInt32(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Int32
	}{
		{Uint32(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Uint32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToInt64(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Int64
	}{
		{Uint32(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Uint32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToInt8(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Int8
	}{
		{Uint32(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Uint32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToTime32(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Time32
	}{
		{Uint32(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Uint32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToTime64(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Time64
	}{
		{Uint32(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Uint32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Timestamp
	}{
		{Uint32(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Uint32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToUint16(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Uint16
	}{
		{Uint32(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Uint32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToUint32(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Uint32
	}{
		{Uint32(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Uint32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToUint64(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Uint64
	}{
		{Uint32(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint32CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Uint32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint32ToUint8(t *testing.T) {
	cases := []struct {
		o    Uint32
		want Uint8
	}{
		{Uint32(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint32ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Uint32
	}{
		{MaxUint32},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToUint32Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint32 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint32 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Uint64
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint64Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint64(0), Uint64(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint64Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint64(0), Uint64(0), nil, false},
		{Uint64(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Uint64"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint64Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint64(0), Uint64(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint64LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint64(0), Uint64(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint64Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint64(0), Uint64(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint64GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint64(0), Uint64(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint64CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Uint64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToBoolean(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Boolean
	}{
		{Uint64(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestUint64CastableToDate32(t *testing.T) {
	cases := []struct {
		o    CastableToDate32
		want Date32
	}{
		{Uint64(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToDate32(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Date32
	}{
		{Uint64(0), Date32(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToDate32Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate32Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Date32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Date32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Uint64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToDate64(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Date64
	}{
		{Uint64(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToDecimal128(t *testing.T) {
	cases := []struct {
		o    CastableToDecimal128
		want Decimal128
	}{
		{Uint64(0), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToDecimal128(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Decimal128
	}{
		{Uint64(0), Decimal128(Decimal128(decimal128.New(0, 0)))},
	}
	for _, c := range cases {
		value := c.o.ToDecimal128()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToDecimal128Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDecimal128Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Decimal128: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Decimal128 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Uint64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToFloat32(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Float32
	}{
		{Uint64(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Uint64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToFloat64(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Float64
	}{
		{Uint64(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Uint64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToInt16(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Int16
	}{
		{Uint64(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Uint64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToInt32(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Int32
	}{
		{Uint64(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Uint64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToInt64(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Int64
	}{
		{Uint64(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Uint64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToInt8(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Int8
	}{
		{Uint64(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Uint64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToTime32(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Time32
	}{
		{Uint64(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Uint64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToTime64(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Time64
	}{
		{Uint64(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Uint64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Timestamp
	}{
		{Uint64(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Uint64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToUint16(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Uint16
	}{
		{Uint64(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Uint64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToUint32(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Uint32
	}{
		{Uint64(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Uint64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToUint64(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Uint64
	}{
		{Uint64(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint64CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Uint64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint64ToUint8(t *testing.T) {
	cases := []struct {
		o    Uint64
		want Uint8
	}{
		{Uint64(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint64ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Uint64
	}{
		{MaxUint64},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToUint64Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint64 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint64 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8ToBoolean(t *testing.T) {
	cases := []struct {
		Obj  Uint8
		Want bool
	}{
		{0, false},
		{1, true},
		{2, true},
	}
	for _, c := range cases {
		if got, want := c.Obj.ToBoolean(), Boolean(c.Want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint8Eq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint8(0), Uint8(0), nil, true},
	}
	for _, c := range cases {
		eq, err := c.left.Eq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := eq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint8Neq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint8(0), Uint8(0), nil, false},
		{Uint8(0), NewNull(), errors.New("cannot cast object.Null (object.Null{}) to object.Uint8"), false},
	}
	for _, c := range cases {
		neq, err := c.left.Neq(c.right)
		if fmt.Sprintf("%v", err) != fmt.Sprintf("%v", c.err) {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := neq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint8Less(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint8(0), Uint8(0), nil, false},
	}
	for _, c := range cases {
		less, err := c.left.Less(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := less, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint8LessEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint8(0), Uint8(0), nil, true},
	}
	for _, c := range cases {
		lessEq, err := c.left.LessEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := lessEq, Boolean(c.want); got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestUint8Greater(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint8(0), Uint8(0), nil, false},
	}
	for _, c := range cases {
		greater, err := c.left.Greater(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greater, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint8GreaterEq(t *testing.T) {
	cases := []struct {
		left  Object
		right Object
		err   error
		want  bool
	}{
		{Uint8(0), Uint8(0), nil, true},
	}
	for _, c := range cases {
		greaterEq, err := c.left.GreaterEq(c.right)
		if err != c.err {
			t.Errorf("wrong value for error:\ngot=%v\nwant=%v", err, c.err)
		}

		if got, want := greaterEq, Boolean(c.want); got != want {
			t.Errorf("\n{left=%v right=%v}\ngot=%v\nwant=%v", c.left, c.right, got, want)
		}
	}
}

func TestUint8CastableToBoolean(t *testing.T) {
	cases := []struct {
		o    CastableToBoolean
		want Boolean
	}{
		{Uint8(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToBoolean(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Boolean
	}{
		{Uint8(0), Boolean(false)},
	}
	for _, c := range cases {
		value := c.o.ToBoolean()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToBooleanChecked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToBooleanChecked()
		if !ok {
			t.Errorf("Boolean should not be returning an overflow: %#v $%v", converted, c.o)
		}
		if converted != Boolean(true) {
			t.Errorf("Boolean should have been converted to Boolean(true): %#v $%v", converted, c.o)
		}
	}
}

func TestUint8CastableToDate64(t *testing.T) {
	cases := []struct {
		o    CastableToDate64
		want Date64
	}{
		{Uint8(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToDate64(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Date64
	}{
		{Uint8(0), Date64(0)},
	}
	for _, c := range cases {
		value := c.o.ToDate64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToDate64Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToDate64Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Date64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Date64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToFloat32(t *testing.T) {
	cases := []struct {
		o    CastableToFloat32
		want Float32
	}{
		{Uint8(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToFloat32(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Float32
	}{
		{Uint8(0), Float32(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToFloat32Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat32Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Float32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Float32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToFloat64(t *testing.T) {
	cases := []struct {
		o    CastableToFloat64
		want Float64
	}{
		{Uint8(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToFloat64(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Float64
	}{
		{Uint8(0), Float64(0)},
	}
	for _, c := range cases {
		value := c.o.ToFloat64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToFloat64Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToFloat64Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Float64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Float64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToInt16(t *testing.T) {
	cases := []struct {
		o    CastableToInt16
		want Int16
	}{
		{Uint8(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToInt16(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Int16
	}{
		{Uint8(0), Int16(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToInt16Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt16Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Int16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Int16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToInt32(t *testing.T) {
	cases := []struct {
		o    CastableToInt32
		want Int32
	}{
		{Uint8(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToInt32(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Int32
	}{
		{Uint8(0), Int32(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToInt32Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt32Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Int32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Int32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToInt64(t *testing.T) {
	cases := []struct {
		o    CastableToInt64
		want Int64
	}{
		{Uint8(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToInt64(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Int64
	}{
		{Uint8(0), Int64(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToInt64Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt64Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Int64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Int64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToInt8(t *testing.T) {
	cases := []struct {
		o    CastableToInt8
		want Int8
	}{
		{Uint8(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToInt8(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Int8
	}{
		{Uint8(0), Int8(0)},
	}
	for _, c := range cases {
		value := c.o.ToInt8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToInt8Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToInt8Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Int8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Int8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToTime32(t *testing.T) {
	cases := []struct {
		o    CastableToTime32
		want Time32
	}{
		{Uint8(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToTime32(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Time32
	}{
		{Uint8(0), Time32(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToTime32Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime32Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Time32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Time32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToTime64(t *testing.T) {
	cases := []struct {
		o    CastableToTime64
		want Time64
	}{
		{Uint8(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToTime64(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Time64
	}{
		{Uint8(0), Time64(0)},
	}
	for _, c := range cases {
		value := c.o.ToTime64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToTime64Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTime64Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Time64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Time64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToTimestamp(t *testing.T) {
	cases := []struct {
		o    CastableToTimestamp
		want Timestamp
	}{
		{Uint8(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToTimestamp(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Timestamp
	}{
		{Uint8(0), Timestamp(0)},
	}
	for _, c := range cases {
		value := c.o.ToTimestamp()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToTimestampChecked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToTimestampChecked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Timestamp: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Timestamp - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToUint16(t *testing.T) {
	cases := []struct {
		o    CastableToUint16
		want Uint16
	}{
		{Uint8(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToUint16(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Uint16
	}{
		{Uint8(0), Uint16(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint16()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToUint16Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint16Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Uint16: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Uint16 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToUint32(t *testing.T) {
	cases := []struct {
		o    CastableToUint32
		want Uint32
	}{
		{Uint8(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToUint32(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Uint32
	}{
		{Uint8(0), Uint32(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint32()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToUint32Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint32Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Uint32: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Uint32 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToUint64(t *testing.T) {
	cases := []struct {
		o    CastableToUint64
		want Uint64
	}{
		{Uint8(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToUint64(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Uint64
	}{
		{Uint8(0), Uint64(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint64()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToUint64Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint64Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Uint64: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Uint64 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}

func TestUint8CastableToUint8(t *testing.T) {
	cases := []struct {
		o    CastableToUint8
		want Uint8
	}{
		{Uint8(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

func TestMethodUint8ToUint8(t *testing.T) {
	cases := []struct {
		o    Uint8
		want Uint8
	}{
		{Uint8(0), Uint8(0)},
	}
	for _, c := range cases {
		value := c.o.ToUint8()

		if got, want := value, c.want; got != want {
			t.Errorf("\ngot=%v\nwant=%v", got, want)
		}
	}
}

// In some cases we don't need to check it when there is no possible overflow
// so this test verifys that we have implemented the Checked method correctly.
func TestMethodUint8ToUint8Checked(t *testing.T) {
	cases := []struct {
		o Uint8
	}{
		{MaxUint8},
	}
	for _, c := range cases {
		converted, ok := c.o.ToUint8Checked()
		if ok {
			v, ok := converted.ToUint8Checked()
			if ok {
				equal, err := v.Eq(c.o)
				if err != nil {
					t.Errorf("error checking for overflow overflow for Uint8 to Uint8: %v", err)
				}
				if err != nil || !equal {
					t.Errorf("detected unhandled overflow for Uint8 to Uint8 - %#v != %#v", v, c.o)
				}
			}
		}
	}
}
